<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/apple-touch-icon.png"><link rel="icon" href="/img/favicon.ico"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"><meta name="theme-color" content="#2f4154"><meta name="author" content="Kovacs"><meta name="keywords" content="多线程,Java,可见性"><meta name="description" content="记录一下 Java 多线程可见性问题"><meta property="og:type" content="article"><meta property="og:title" content="Java 多线程可见性问题"><meta property="og:url" content="https://mritd.com/2016/03/20/java-multithreading-variable-visibility/index.html"><meta property="og:site_name" content="Kovacs"><meta property="og:description" content="记录一下 Java 多线程可见性问题"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://cdn.oss.link/markdown/hexo_java_thread_memory1.png"><meta property="og:image" content="https://cdn.oss.link/markdown/hexo_java_thread_memory2.png"><meta property="og:image" content="https://cdn.oss.link/markdown/hexo_java_thread_memory3.png"><meta property="article:published_time" content="2016-03-20T07:04:32.000Z"><meta property="article:modified_time" content="2016-03-20T07:04:32.000Z"><meta property="article:author" content="Kovacs"><meta property="article:tag" content="Java"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://cdn.oss.link/markdown/hexo_java_thread_memory1.png"><meta name="twitter:creator" content="@kovacs_orz"><meta name="twitter:site" content="https://twitter.com/kovacs_orz"><title>Java 多线程可见性问题 - Kovacs</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var CONFIG={hostname:"mritd.com",root:"/",version:"1.9.7",typing:{enable:!0,typeSpeed:80,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"right",visible:"hover",icon:"❡"},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!0,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:3},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!0,follow_dnt:!0,baidu:null,google:{measurement_id:"G-H06NPECR0Z"},tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:null,app_key:null,server_url:null,path:"window.location.pathname",ignore_local:!1}},search_path:"/local-search.xml",include_content_in_search:!0};if(CONFIG.web_analytics.follow_dnt){var dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack;Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on"))}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><script async>Fluid.ctx.dnt||Fluid.utils.createScript("https://www.googletagmanager.com/gtag/js?id=G-H06NPECR0Z",(function(){function a(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],a("js",new Date),a("config","G-H06NPECR0Z")}))</script><meta name="generator" content="Hexo 7.0.0"><link rel="alternate" href="/atom.xml" title="Kovacs" type="application/atom+xml">
<link rel="alternate" href="/rss.xml" title="Kovacs" type="application/rss+xml">
</head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>Kovacs</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/" target="_self"><i class="iconfont icon-home-fill"></i> <span>首页</span></a></li><li class="nav-item"><a class="nav-link" href="/archives/" target="_self"><i class="iconfont icon-archive-fill"></i> <span>归档</span></a></li><li class="nav-item"><a class="nav-link" href="/categories/" target="_self"><i class="iconfont icon-category-fill"></i> <span>分类</span></a></li><li class="nav-item"><a class="nav-link" href="/tags/" target="_self"><i class="iconfont icon-tags-fill"></i> <span>标签</span></a></li><li class="nav-item"><a class="nav-link" href="/about/" target="_self"><i class="iconfont icon-user-fill"></i> <span>关于</span></a></li><li class="nav-item"><a class="nav-link" href="/friends/" target="_self"><i class="iconfont icon-link-fill"></i> <span>友链</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/img/default.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="Java 多线程可见性问题"></span></div><div class="mt-3"><span class="post-meta mr-2"><i class="iconfont icon-author" aria-hidden="true"></i> Kovacs </span><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2016-03-20 15:04" pubdate>2016年3月20日 下午</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 2k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 17 分钟</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 id="seo-header">Java 多线程可见性问题</h1><div class="markdown-body"><h2 id="一、相关定义"><a href="#一、相关定义" class="headerlink" title="一、相关定义"></a>一、相关定义</h2><h3 id="1、可见性"><a href="#1、可见性" class="headerlink" title="1、可见性"></a>1、可见性</h3><p>在多线程中，如果一个线程对某一 <strong>共享变量</strong> 的修改，<strong>能及时被其他线程所感知</strong>，这个特性或者说过程称之为线程可见性。</p><h3 id="2、共享变量"><a href="#2、共享变量" class="headerlink" title="2、共享变量"></a>2、共享变量</h3><p>当多线程同时操作一个变量时，该变量在多线程的 <strong>工作内存(私有内存)</strong> 中都存在一个副本，那么这个变量称之为这几个线程的共享变量。</p><h3 id="3、工作内存"><a href="#3、工作内存" class="headerlink" title="3、工作内存"></a>3、工作内存</h3><p>多线程工作时，每个线程都会复制主内存中的变量副本到自己的私有内存，这个私有内存称之为每个线程的工作内存。</p><h2 id="二、Java-内存模型-Java-Memory-Model"><a href="#二、Java-内存模型-Java-Memory-Model" class="headerlink" title="二、Java 内存模型(Java Memory Model)"></a>二、Java 内存模型(Java Memory Model)</h2><blockquote><p><strong>Java 内存模型(JMM) 描述了 Java 程序中对线程共享变量的访问规则，以及在 JVM 层面对内存读写变量的底层细节，详细可参考 <a target="_blank" rel="noopener" href="http://www.infoq.com/cn/articles/java-memory-model-1">InfoQ-深入理解Java内存模型</a></strong></p></blockquote><h3 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h3><p>简单地说，Java 内存模型规定，所有实例域、静态域和数组元素存储在堆内存中，堆内存在线程之间共享，局部变量(Local variables)，方法定义参数(java语言规范称之为formal method parameters)和异常处理器参数(exception handler parameters)不会在线程之间共享；运行时将所有变量放入 <strong>主内存中</strong>，同时在多线程访问的情况下，每个线程会开辟自己的 <strong>工作内存(抽象)<strong>；</strong>工作内存中用于存放该线程所用到的每个主内存中的变量副本</strong>，图例如下：</p><p><img src="https://cdn.oss.link/markdown/hexo_java_thread_memory1.png" srcset="/img/loading.gif" lazyload alt="Java 内存模型1"></p><h3 id="2、线程读写变量规则"><a href="#2、线程读写变量规则" class="headerlink" title="2、线程读写变量规则"></a>2、线程读写变量规则</h3><p>JMM 规定，多线程情况下，每个线程对变量的操作 <strong>必须在自己的工作内存</strong> 中完成，<strong>不允许线程直接对主内存进行操作</strong>。</p><p>多线程变量传递需要借助主内存中转；<strong>也就是说，当A线程需要改变变量值时，需要先改变当前工作内存中的变量，再将其刷新到主内存，最后通过主内存刷新到线程B的工作内存。</strong>图例如下：</p><p><img src="https://cdn.oss.link/markdown/hexo_java_thread_memory2.png" srcset="/img/loading.gif" lazyload alt="Java 内存模型2"></p><p><img src="https://cdn.oss.link/markdown/hexo_java_thread_memory3.png" srcset="/img/loading.gif" lazyload alt="Java 内存模型3"></p><h2 id="三、synchronized-实现可见性"><a href="#三、synchronized-实现可见性" class="headerlink" title="三、synchronized 实现可见性"></a>三、synchronized 实现可见性</h2><p>Java 中对代码块或方法使用 <code>symchroized</code> 关键字，可保证其内部的共享变量实现多线程可见性。</p><h3 id="1、JMM-对-synchroized-相关规定"><a href="#1、JMM-对-synchroized-相关规定" class="headerlink" title="1、JMM 对 synchroized 相关规定"></a>1、JMM 对 synchroized 相关规定</h3><ul><li>线程解锁前，必须将工作内存中数据刷新到主内存。</li><li>线程加锁时，必须先清空工作内存，然后将主内存数据刷新到工作内存</li></ul><h3 id="2、线程执行互斥代码过程"><a href="#2、线程执行互斥代码过程" class="headerlink" title="2、线程执行互斥代码过程"></a>2、线程执行互斥代码过程</h3><ul><li>1、线程在 <code>synchroized</code> 入口处获得互斥锁</li><li>2、线程清空自己的工作内存</li><li>3、线程将主内存数据刷新到工作内存</li><li>4、线程执行互斥代码</li><li>5、线程将工作内存数据刷新到主内存</li><li>6、线程退出 <code>synchroized</code> 代码块并释放互斥锁</li></ul><h3 id="3、指令重排序"><a href="#3、指令重排序" class="headerlink" title="3、指令重排序"></a>3、指令重排序</h3><blockquote><p>具体可参考 <a target="_blank" rel="noopener" href="http://www.infoq.com/cn/articles/java-memory-model-2">InfoQ 深入理解Java内存模型（二）-重排序</a></p></blockquote><p><strong>定义：</strong>指令重排序，简单地说就是编译器和CPU为了提高并行执行速度，进行的代码重排序执行。</p><p>在CPU执行层面，每执行一个指令也会类似 Java 语言的 I&#x2F;O 操作，在某一个命令未执行完成时必须进入等待(阻塞状态)，然后执行下一个命令；而编译器和CPU为了最大限度利用有限时间执行更多的任务，可能会进行指令重排序；指令重排序结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 原有代码</span><br><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<br></code></pre></td></tr></table></figure><p>在编译器和CPU优化后，重排序可能会出现如下结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 重排序后</span><br><span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><p><strong>但是指令重排序会遵循一点：as-if-serail 语义，即在单线程的情况下，保证最终执行结果不变，这时才会进行指令重排序；</strong>如上所示，a与b哪个先定义都不会产生结果的变更时才会重排序。</p><h3 id="4、代码示例"><a href="#4、代码示例" class="headerlink" title="4、代码示例"></a>4、代码示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> mkw.demo.syn;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SynchronizedDemo</span> &#123;<br>	<span class="hljs-comment">//共享变量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">ready</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;   <br>    <span class="hljs-comment">//写操作</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">()</span>&#123;<br>    	ready = <span class="hljs-literal">true</span>;	      		 <span class="hljs-comment">//1.1				</span><br>    	number = <span class="hljs-number">2</span>;                      <span class="hljs-comment">//1.2			    </span><br>    &#125;<br>    <span class="hljs-comment">//读操作</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">read</span><span class="hljs-params">()</span>&#123;			   	 <br>    	<span class="hljs-keyword">if</span>(ready)&#123;		         <span class="hljs-comment">//2.1</span><br>    		result = number*<span class="hljs-number">3</span>;	 <span class="hljs-comment">//2.2</span><br>    	&#125;   	<br>    	System.out.println(<span class="hljs-string">&quot;result的值为：&quot;</span> + result);<br>    &#125;<br><br>    <span class="hljs-comment">//内部线程类</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReadWriteThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    	<span class="hljs-comment">//根据构造方法中传入的flag参数，确定线程执行读操作还是写操作</span><br>    	<span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> flag;<br>    	<span class="hljs-keyword">public</span> <span class="hljs-title function_">ReadWriteThread</span><span class="hljs-params">(<span class="hljs-type">boolean</span> flag)</span>&#123;<br>    		<span class="hljs-built_in">this</span>.flag = flag;<br>    	&#125;<br>        <span class="hljs-meta">@Override</span>                                                                    <br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        	<span class="hljs-keyword">if</span>(flag)&#123;<br>        		<span class="hljs-comment">//构造方法中传入true，执行写操作</span><br>        		write();<br>        	&#125;<span class="hljs-keyword">else</span>&#123;<br>        		<span class="hljs-comment">//构造方法中传入false，执行读操作</span><br>        		read();<br>        	&#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>  &#123;<br>    	<span class="hljs-type">SynchronizedDemo</span> <span class="hljs-variable">synDemo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SynchronizedDemo</span>();<br>    	<span class="hljs-comment">//启动线程执行写操作</span><br>    	synDemo .<span class="hljs-keyword">new</span> <span class="hljs-title class_">ReadWriteThread</span>(<span class="hljs-literal">true</span>).start();<br>    	<span class="hljs-comment">//启动线程执行读操作</span><br>    	synDemo.<span class="hljs-keyword">new</span> <span class="hljs-title class_">ReadWriteThread</span>(<span class="hljs-literal">false</span>).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行 mian 方法，由于可见性问题，可能出现多种情况，比如 写线程执行到 1.1，读线程获取CPU资源立即执行、写线程指令 1.1、1.2重排序等等情况。</p><h2 id="四、volatile-实现可见性控制"><a href="#四、volatile-实现可见性控制" class="headerlink" title="四、volatile 实现可见性控制"></a>四、volatile 实现可见性控制</h2><h3 id="1、实现原理"><a href="#1、实现原理" class="headerlink" title="1、实现原理"></a>1、实现原理</h3><p>volatile 通过加入内存屏障和禁止指令重排序实现可见性控制，其过程大致分为以下两个过程：</p><ul><li>对 volatile 变量进行写操作时，会在写操作后加入一条 <code>store</code> 屏蔽指令；<strong>该命令会将工作内存中内容强制刷新到主内存(覆盖)；同时会防止编译器&#x2F;CPU指令重排序时将前面的变量重排到 volatile 修饰的变量之后(禁止颠倒顺序)。</strong></li><li>对 volatile 变量进行读操作时，会在读操作前加入一条 <code>load</code> 屏蔽指令；<strong>该指令会强制使工作内存失效，从而达到必须从主内存刷新到工作内存的效果</strong></li></ul><p>总结：使用 valotile 修饰变量后，线程在每次读取该变量时，会强制从主内存刷新最新状态到工作内存；在每次写入该变量时，会强制从工作内存刷新到主内存，以保证线程可见性。</p><h3 id="2、volatile-不能保证原子性"><a href="#2、volatile-不能保证原子性" class="headerlink" title="2、volatile 不能保证原子性"></a>2、volatile 不能保证原子性</h3><p>由上可知 volatile 在保证可见性的原理大致和 synchroized 类似，主要是控制工作内存与主内存的刷新关系；但是相对于 synchroized ，volatile 不能保证原子性操作，测试代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> mkw.demo.vol;<br><br><span class="hljs-keyword">import</span> java.util.concurrent.locks.Lock;<br><span class="hljs-keyword">import</span> java.util.concurrent.locks.ReentrantLock;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VolatileDemo</span> &#123;<br><br>        <span class="hljs-comment">// 测试变量</span><br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>	<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getNumber</span><span class="hljs-params">()</span>&#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.number;<br>	&#125;<br><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">increase</span><span class="hljs-params">()</span>&#123;<br>		<span class="hljs-keyword">try</span> &#123;<br>			Thread.sleep(<span class="hljs-number">100</span>);<br>		&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>			e.printStackTrace();<br>		&#125;<br><br>		<span class="hljs-built_in">this</span>.number++;<br>	&#125;<br><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>		<span class="hljs-comment">// TODO Auto-generated method stub</span><br>		<span class="hljs-keyword">final</span> <span class="hljs-type">VolatileDemo</span> <span class="hljs-variable">volDemo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">VolatileDemo</span>();<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">500</span> ; i++)&#123;<br>			<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br><br>				<span class="hljs-meta">@Override</span><br>				<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>					volDemo.increase();<br>				&#125;<br>			&#125;).start();<br>		&#125;<br><br>		<span class="hljs-comment">//如果还有子线程在运行，主线程就让出CPU资源，</span><br>		<span class="hljs-comment">//直到所有的子线程都运行完了，主线程再继续往下执行</span><br>		<span class="hljs-keyword">while</span>(Thread.activeCount() &gt; <span class="hljs-number">1</span>)&#123;<br>			Thread.<span class="hljs-keyword">yield</span>();<br>		&#125;<br><br>		System.out.println(<span class="hljs-string">&quot;number : &quot;</span> + volDemo.getNumber());<br>	&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>当以上代码运行多次后，number 打印的值会出现很多小于500的情况；其原因是 volatile 无法保证 number++ 这行代码的原子性操作；实质上 <code>number++</code> 执行了3个动作，首先读取 number 值，然后进行+1，最后写会 number；</p><p>首先假设 number&#x3D;2，在多线程并发的情况下，A线程由于 volatile 原因，首先将 number 从主内存强制刷新到工作内存，然后进行 +1 操作，此时A线程工作内存中 number&#x3D;3，当要回写到工作内存时。线程 B 获取了CPU资源开始执行；不难想象，B线程对 number+1 后，可能被A线程覆盖掉；此时 volatile 无法保证原子性的问题就暴露了出来。</p><h3 id="3、volatile-适用场景"><a href="#3、volatile-适用场景" class="headerlink" title="3、volatile 适用场景"></a>3、volatile 适用场景</h3><ul><li>对变量的写不依赖于当前值；即直接强制写，同时写的值跟上一次没关系。</li><li>该变量不包含在其他变量的不变式中；即与其他 volatile 变量没关系。</li></ul><h3 id="4、volatile-与-synchroized-比较"><a href="#4、volatile-与-synchroized-比较" class="headerlink" title="4、volatile 与 synchroized 比较"></a>4、volatile 与 synchroized 比较</h3><p>在可见性上，volatile 与 synchroized 基本是相同的；但是在原子性上，volatile不支持；<strong>同时 synchroized 会执行加锁动作，开销较大，而 volatile 更轻量级。</strong></p></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/java/" class="category-chain-item">Java</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/java/" class="print-no-link">#Java</a></div></div><div class="license-box my-3"><div class="license-title"><div>Java 多线程可见性问题</div><div>https://mritd.com/2016/03/20/java-multithreading-variable-visibility/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>Kovacs</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2016年3月20日</div></div><div class="license-meta-item"><div>许可协议</div><div><a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-by"></i> </span></a><a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><span class="hint--top hint--rounded" aria-label="NC - 非商业性使用"><i class="iconfont icon-nc"></i> </span></a><a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><span class="hint--top hint--rounded" aria-label="SA - 相同方式共享"><i class="iconfont icon-sa"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/2016/03/21/java-memory-java-heap/" title="Java 内存之 Java 堆"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">Java 内存之 Java 堆</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/2016/03/14/sql-or-keyword-priority/" title="SQL中 OR 关键字优先级问题"><span class="hidden-mobile">SQL中 OR 关键字优先级问题</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article id="comments" lazyload><div class="disqus" style="width:100%"><div id="disqus_thread"></div><script type="text/javascript">var disqus_config=function(){this.page.url="https://mritd.com/2016/03/20/java-multithreading-variable-visibility/",this.page.identifier="/2016/03/20/java-multithreading-variable-visibility/"};Fluid.utils.loadComments("#disqus_thread",(function(){var i=document,t=i.createElement("script");t.src="//bleem.disqus.com/embed.js",t.setAttribute("data-timestamp",new Date),(i.head||i.body).appendChild(t)}))</script><noscript>Please enable JavaScript to view the comments</noscript></div></article></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> <i class="iconfont icon-docker"></i> <a href="https://bandwagonhost.com/aff.php?aff=61367" target="_blank" rel="nofollow noopener"><span>BandwagonHost</span></a></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!0,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t,e){var i=Fluid.plugins.typing,n=e.getElementById("subtitle");n&&i&&i(n.getAttribute("data-typed-text"))}(window,document)</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js",(function(){var t=jQuery("#toc");if(0!==t.length&&window.tocbot){var i=jQuery("#board-ctn").offset().top;window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-i},CONFIG.toc)),t.find(".toc-list-item").length>0&&t.css("visibility","visible"),Fluid.events.registerRefreshCallback((function(){if("tocbot"in window){tocbot.refresh();var t=jQuery("#toc");if(0===t.length||!tocbot)return;t.find(".toc-list-item").length>0&&t.css("visibility","visible")}}))}}))</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js",(function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(o.join(", ")),Fluid.events.registerRefreshCallback((function(){if("anchors"in window){anchors.removeAll();var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(anchors.options.class="anchorjs-link-left"),anchors.add(o.join(", "))}}))}))</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",(function(){Fluid.plugins.fancyBox()}))</script><script>Fluid.plugins.imageCaption()</script><script src="/js/local-search.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript></body></html>