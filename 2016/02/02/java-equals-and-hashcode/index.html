<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/apple-touch-icon.png"><link rel="icon" href="/img/favicon.ico"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"><meta name="theme-color" content="#2f4154"><meta name="author" content="Kovacs"><meta name="keywords" content="equals,hashcode"><meta name="description" content="介绍 java 中的 equals 和 hashcode 方法"><meta property="og:type" content="article"><meta property="og:title" content="浅谈 java中的 equals 和 hashcode"><meta property="og:url" content="https://mritd.com/2016/02/02/java-equals-and-hashcode/index.html"><meta property="og:site_name" content="Kovacs"><meta property="og:description" content="介绍 java 中的 equals 和 hashcode 方法"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://cdn.oss.link/markdown/hexo_java_equals_hashcode.jpg"><meta property="article:published_time" content="2016-02-02T07:04:26.000Z"><meta property="article:modified_time" content="2016-02-02T07:04:26.000Z"><meta property="article:author" content="Kovacs"><meta property="article:tag" content="Java"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://cdn.oss.link/markdown/hexo_java_equals_hashcode.jpg"><meta name="twitter:creator" content="@kovacs_orz"><meta name="twitter:site" content="https://twitter.com/kovacs_orz"><title>浅谈 java中的 equals 和 hashcode - Kovacs</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var CONFIG={hostname:"mritd.com",root:"/",version:"1.9.7",typing:{enable:!0,typeSpeed:80,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"right",visible:"hover",icon:"❡"},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!0,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:3},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!0,follow_dnt:!0,baidu:null,google:{measurement_id:"G-H06NPECR0Z"},tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:null,app_key:null,server_url:null,path:"window.location.pathname",ignore_local:!1}},search_path:"/local-search.xml",include_content_in_search:!0};if(CONFIG.web_analytics.follow_dnt){var dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack;Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on"))}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><script async>Fluid.ctx.dnt||Fluid.utils.createScript("https://www.googletagmanager.com/gtag/js?id=G-H06NPECR0Z",(function(){function a(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],a("js",new Date),a("config","G-H06NPECR0Z")}))</script><meta name="generator" content="Hexo 7.0.0"><link rel="alternate" href="/atom.xml" title="Kovacs" type="application/atom+xml">
<link rel="alternate" href="/rss.xml" title="Kovacs" type="application/rss+xml">
</head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>Kovacs</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/" target="_self"><i class="iconfont icon-home-fill"></i> <span>首页</span></a></li><li class="nav-item"><a class="nav-link" href="/archives/" target="_self"><i class="iconfont icon-archive-fill"></i> <span>归档</span></a></li><li class="nav-item"><a class="nav-link" href="/categories/" target="_self"><i class="iconfont icon-category-fill"></i> <span>分类</span></a></li><li class="nav-item"><a class="nav-link" href="/tags/" target="_self"><i class="iconfont icon-tags-fill"></i> <span>标签</span></a></li><li class="nav-item"><a class="nav-link" href="/about/" target="_self"><i class="iconfont icon-user-fill"></i> <span>关于</span></a></li><li class="nav-item"><a class="nav-link" href="/friends/" target="_self"><i class="iconfont icon-link-fill"></i> <span>友链</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/img/default.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="浅谈 java中的 equals 和 hashcode"></span></div><div class="mt-3"><span class="post-meta mr-2"><i class="iconfont icon-author" aria-hidden="true"></i> Kovacs </span><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2016-02-02 15:04" pubdate>2016年2月2日 下午</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 2.7k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 23 分钟</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 id="seo-header">浅谈 java中的 equals 和 hashcode</h1><div class="markdown-body"><p><img src="https://cdn.oss.link/markdown/hexo_java_equals_hashcode.jpg" srcset="/img/loading.gif" lazyload alt="hexo_java_equals_hashcode.jpg"></p><h2 id="equals-方法"><a href="#equals-方法" class="headerlink" title="equals 方法"></a>equals 方法</h2><blockquote><p>equals 方法来源于 Object 超类；该方法用于检测一个对象与另一个对象是否相等。</p></blockquote><h3 id="Object-中的-equals"><a href="#Object-中的-equals" class="headerlink" title="Object 中的 equals"></a>Object 中的 equals</h3><blockquote><p>在 java 源码中，Object 的 equals 实现如下</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object obj)</span> &#123;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-built_in">this</span> == obj);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>由此可见，Object 中 equals 默认比较的是两个对象的 内存地址(&#x3D;&#x3D;)，即 <strong>默认比较两个对象的引用，引用相同返回true，反之返回false。</strong>这看起来似乎合情合理，但实际开发中，这种比较方式则不适用；比如我们要比较两个 pserson 对象是否相等，<strong>从业务角度来说，只要这两个人 名字、年龄、身份证号相同，我们就可以认为两个对象相等。但由于是两个 pserson对象，所以所以引用肯定不同，这样调用默认的 equals 方法就会返回 false，显然是不合理的。</strong></p></blockquote><h3 id="重写-equals"><a href="#重写-equals" class="headerlink" title="重写 equals"></a>重写 equals</h3><blockquote><p>从上面的例子可以看出，Object 中的 equals 并不适用与实际业务场景，此时我们应该 对 equals进行重写；但是 重写 equals 必须满足以下规则(特性)：</p></blockquote><ul><li><p>自反性</p><blockquote><p>对于对象 x ，<code>x.equals(x)</code> 应当始终返回 true。</p></blockquote></li><li><p>对称性</p><blockquote><p>对于对象 x、y，如果 <code>x.equals(y)</code> 返回 true，那么 <code>y.equals(x)</code> 也必须返回 true。</p></blockquote></li><li><p>传递性</p><blockquote><p>对于对象 x、y、z，如果 <code>x.equals(y)</code> 返回 true，<code>y.equals(z)</code> 返回 true；那么 <code>x.equals(z)</code> 也必须返回 true。</p></blockquote></li><li><p>一致性</p><blockquote><p>对于对象 x、y，如果 <code>x.equals(y)</code> 返回 true，那么反复调用的结果应当一直为 true。</p></blockquote></li><li><p>空值不行等性</p><blockquote><p>对于任意非空对象 x，<code>x.equals(null)</code> 应当永远返回 false。</p></blockquote></li></ul><hr><p><strong>然而，对于以上5种特性，在某些特殊情况下需要严格考虑。</strong></p><ul><li>对象属性的冲突</li></ul><p>假设我们将对象内的属性看作是对象内容，在实际业务场景，可能一个 汽车 Car 对象 和一个人 pserson 对象具有相同的名字，比如 <code>特斯拉</code>；此时如果我们重写 equals 时仅仅比较对象内容的话，很可能误判为 <strong>一辆汽车和一个人相等</strong>；是的，这很滑稽。</p><h3 id="getClass-的使用"><a href="#getClass-的使用" class="headerlink" title="getClass 的使用"></a>getClass 的使用</h3><p>在上面列举的情况来看，我们似乎再重写 equals 时还需要考虑对象的类型；在 java 里，对象类型我们 采用 Class 描述。那么此时 我们在重写的 equals 方法里应当 增加 <code>car.getClass()==pserson.getClass()</code> 的检测，这样能有效避免上述情况的发生；伪代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object obj)</span>&#123;<br>    <span class="hljs-comment">// 进行完全匹配检测(引用)</span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>==obj) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-comment">// 进行空值检测</span><br>    <span class="hljs-keyword">if</span>(obj==<span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">// 进行类型匹配检测</span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.getClass()!=obj.getClass()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">// 进行属性相等检测，省略...</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="instanceof-的使用"><a href="#instanceof-的使用" class="headerlink" title="instanceof 的使用"></a>instanceof 的使用</h3><p>然而，即使我们考虑了属性相等的情况，我们还是忽略了很多其他的业务场合。比如 一个学生 Student 对象和一个人 pserson 对象；当使用上面的检测方法时，很明显 pserson 对象和 Student 对象的 Class 不一致，直接返回了 false；而实际业务场景是 一个 Student 对象也是一个人 pserson；<strong>Student 对象可能继承于pserson对象。</strong>而此时我们应当使用 instanceof 进行检测，伪代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object obj)</span>&#123;<br>    <span class="hljs-comment">// 进行完全匹配检测(引用)</span><br>    <span class="hljs-keyword">if</span>(!(<span class="hljs-built_in">this</span> instaceof obj)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">// 进行空值检测</span><br>    <span class="hljs-keyword">if</span>(obj==<span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">// 进行类型匹配检测</span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.getClass()!=obj.getClass()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">// 进行属性相等检测，省略...</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="getClass-与-instaceof-的取舍"><a href="#getClass-与-instaceof-的取舍" class="headerlink" title="getClass 与 instaceof 的取舍"></a>getClass 与 instaceof 的取舍</h3><p>或许从上两个例子中我们感觉使用 instaceof 更 “靠谱一些”；但其实我们注意到，<strong>采用 instaceof 检测实际上违反了 <code>对称性</code> 原则；</strong> 因为 <code>pserson instaceof Student</code> 返回 false，反之返回 true。</p><p>所以对于 <code>instanceof</code> 有时候并不那么完美；就连 JDK的开发者也遇到了这个问题；在 <code>Timestamp</code> 类中，由于继承自 <code>java.util.Date</code>；而不幸的是 Date 类的 equals 采用的是 instanceof，这就导致对称性出了问题。从上可知，我们根据实际业务进行取舍，取舍原则如下：</p><ul><li>如果子类拥有自己的相等性概念，则对称性强制要求采用 getClass 方式检测。</li><li>如果由超类决定相等性概念，那么就可以采用 instanceof 检测，保证我们可以在子类对象间进行相等性判断。</li></ul><h3 id="重写-equals-的建议"><a href="#重写-equals-的建议" class="headerlink" title="重写 equals 的建议"></a>重写 equals 的建议</h3><ul><li>首先检测 this 与 otherObject 是否引用同一对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>==otherObject) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br></code></pre></td></tr></table></figure><ul><li>然后检测 otherObject是否为 null，如果为 null 返回 false，这是必须的</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(otherObject == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br></code></pre></td></tr></table></figure><ul><li>其次比较 this 与 otherObject 是否同属于一个类；如果 equals 语义在子类中有所改变，则 使用 getClass 检测</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.getClass()!=otherObject.getClass()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br></code></pre></td></tr></table></figure><ul><li>最后将 otherObject强制转换为 当前类型，并进行属性值检测；注意：<strong>如果在子类中重写的equals，则需要在重写时首先进行 <code>super.equals(other)</code> 判断</strong></li></ul><h2 id="hashcode-方法"><a href="#hashcode-方法" class="headerlink" title="hashcode 方法"></a>hashcode 方法</h2><blockquote><p>写这篇博客之前，也看过很多博客，大部分大家写的都是这样的一句话：<strong>重写 equals 必须重写 hashcode，两个对象 equals 返回 true 则 hashcode 必须保证相同。</strong>但是，接下来就没有然后了；搞的我刚学 java 时候也挺晕的，就像是 “知其然而不知所以然”。</p></blockquote><blockquote><p>总结一下一般会有这几个问题：</p></blockquote><ul><li>hashcode 方法是干啥的？</li><li>hashcode(哈希值) 是个什么玩意？</li><li>hashcode 有什么用？</li><li>我为啥要重写 hashcode？</li><li>我不重写它有啥后果？</li></ul><h3 id="hashcode-方法是干啥的？"><a href="#hashcode-方法是干啥的？" class="headerlink" title="hashcode 方法是干啥的？"></a>hashcode 方法是干啥的？</h3><blockquote><p>官方的解释是这样的：<strong>hashcode 方法用于返回一个对象的 哈希值。</strong>说白了就是 hashcode 方法能返回一个 哈希值，这玩意是个整数。</p></blockquote><h3 id="hashcode-哈希值-是个什么玩意？"><a href="#hashcode-哈希值-是个什么玩意？" class="headerlink" title="hashcode(哈希值) 是个什么玩意？"></a>hashcode(哈希值) 是个什么玩意？</h3><blockquote><p>由上面可知，这个 哈希值就是一个整数，可能是正数也可能是负数。</p></blockquote><h3 id="hashcode-有什么用？"><a href="#hashcode-有什么用？" class="headerlink" title="hashcode 有什么用？"></a>hashcode 有什么用？</h3><blockquote><p>hashcode(哈希值) 的作用就是用于在使用 Hash算法实现的集合中确定元素位置。</p></blockquote><p>拿我们最常见的 HashMap 来说，我们都知道 HashMap 里通过 key 取 value 时的速度 是 O(1) 级别的；</p><p>什么是 O(1)级别？</p><p>O(1)级别说白了就是 <strong>在任意数据大小的容器中，取出一个元素所使用的时间与元素个数无关；通俗的说法就是 不论你这个 HashMap 里有100个元素还是有9999999个元素，我通过 key 取出一个元素所使用的时间是一样的。</strong></p><p>为何是 O(1) 级别？为何这么吊？</p><p>这个问题就要谈一下 HashMap 等 hash 容器的存储方式了；这些容器在存储元素是是这样的：首先获取你要存储元素的 hashcode(一个整数)，然后再定义一个固定整数(标准叫桶数)，最后用 hashcode 对 另一个整数(桶数) 取余；取余的结果即为元素要存储的下标(可能存放到数组里)。当然这里是简单的取余，可能更复杂。</p><p>当我们要从一个 HashMap 中取出一个 value 时，实际上他就是通过这套算法，用 key 的 hashcode 计算出元素位置，直接取出来了；所以说 无论你这里面有多少元素，它取的时候始终是用着一个算法、一个流程，不会因为你数据多少而产生影响，这就是 O(1) 级别的存储。</p><p><strong>总结：由上面可知，这个 hashcode 的作用就是 通过算法来确立元素存放的位置，以便于放入元素或者获取元素。</strong></p><h3 id="我为啥要重写-hashcode-不重写有啥后果"><a href="#我为啥要重写-hashcode-不重写有啥后果" class="headerlink" title="我为啥要重写 hashcode &amp;&amp; 不重写有啥后果"></a>我为啥要重写 hashcode &amp;&amp; 不重写有啥后果</h3><blockquote><p>回顾一下上面：hashcode 是个整数，hashcode 方法的作用就是计算并返回这个整数；这个整数用于存放 Hash 算法实现的容器时 确定元素位置。</p></blockquote><p>接下来考虑一个业务场景：有两个对象 pserson1 和 pserson2 ，pserson1 和 pserson2 都只有两个属性，分别是名字(name)和年龄(age)。现在 pserson1 和 pserson2 的名字(name)、年龄(age) 都相同；那么我们是否可以根据业务场景来说 <strong>pserson1 和 pserson2 是同一个人</strong>？</p><p>如果说 “是” 的话，我们刚刚所认为的 “从业务角度理解 pserson1 和 pserson2 是一个人” 是不是就相当于 重写了 Pserson 的 equals 方法呢？就像下面这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Pserson</span> &#123;<br>	<span class="hljs-keyword">private</span> String name;<br>	<span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br><br>	<span class="hljs-comment">// 重写 equals</span><br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object obj)</span> &#123;<br>		<span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span> == obj)<br>			<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>		<span class="hljs-keyword">if</span> (obj == <span class="hljs-literal">null</span>)<br>			<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>		<span class="hljs-keyword">if</span> (getClass() != obj.getClass())<br>			<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>		<span class="hljs-comment">// 主要在这，我们根据业务逻辑，即 姓名和年龄 确立相等关系</span><br>		<span class="hljs-type">pserson</span> <span class="hljs-variable">other</span> <span class="hljs-operator">=</span> (pserson) obj;<br>		<span class="hljs-keyword">if</span> (age != other.age)<br>			<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>		<span class="hljs-keyword">if</span> (name == <span class="hljs-literal">null</span>) &#123;<br>			<span class="hljs-keyword">if</span> (other.name != <span class="hljs-literal">null</span>)<br>				<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>		&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!name.equals(other.name))<br>			<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们注意到，我们根据业务逻辑重写 equals 后，造成的结果就是，两个 属性相同的 Pserson 对象 我们就认为是相同的，即 equals 返回了 true；<br><strong>但我们没有重写 hashcode，Object 中的 hashcode 是 native(本地的)，也就是很可能不同对象返回不同的 hashcode，即使属性相同也没用。</strong></p><hr><p>到这里我们再总结一下：</p><ul><li><strong>hashcode 方法返回对象的 哈希值；</strong></li><li><strong>我们通过 哈希值 的运算(与指定数取余等)来确立元素在 hash 算法实现的容器中的位置；</strong></li><li><strong>Object 中的 hashcode 方法 对于业务逻辑上相等的两个对象(属性相同，不同引用) 返回的 hashcode 是不同的。</strong></li></ul><hr><p><strong>墨迹了那么多最终问题来了：假设我们只重写了 pserson 的 equals 方法，使之 “属性相同即为相等”，当我们把两个 “相等的(属性相同的)” Pserson 对象 放入 HashSet 中会怎样？</strong></p><p>友情提示：HashSet中默认是不许放重复元素的，放重复的是会被过滤掉的，如下代码所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test1</span> &#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>		<span class="hljs-type">Pserson</span> <span class="hljs-variable">pserson1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Pserson</span>();<br>		pserson1.setName(<span class="hljs-string">&quot;张三&quot;</span>);<br>		pserson1.setAge(<span class="hljs-number">10</span>);<br><br>		<span class="hljs-type">Pserson</span> <span class="hljs-variable">pserson2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Pserson</span>();<br>		pserson2.setName(<span class="hljs-string">&quot;张三&quot;</span>);<br>		pserson2.setAge(<span class="hljs-number">10</span>);<br><br>		HashSet&lt;Pserson&gt; hashSet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;Pserson&gt;();<br><br>		hashSet.add(pserson1);<br>		hashSet.add(pserson2);<br><br>		System.out.println(hashSet.size());<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>结论&amp;&amp;后果：当我们仅重写了 equals 保证了 “名字和年龄一样的就是一个人” 这条业务以后；把两个 pserson 对象放入 HashSet 容器里时，由于 HashSet 是通过 hashcode 来区分两个 对象存放位置，而我们又 没有根据业务逻辑重写 hashcode 方法；导致了两个 在业务上相同的对象 放到了 HashSet里，HashSet 会认为他是两个不同的对象，故最后不会去重，hashset.size()打印出来是2。</p></blockquote><h2 id="最终结论"><a href="#最终结论" class="headerlink" title="最终结论"></a>最终结论</h2><blockquote><p>对于重写 euqals ，要很据实际业务逻辑来，并满足上述的设计要求；一旦重写了 equals 那就必须重写 hashcode，除非你保证你的对象不会被放到 Hash 实现的容器里；不重写的话就会导致 Hash 容器认为两个属性相同的对象是2个，而不是业务上的1个。</p></blockquote></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/java/" class="category-chain-item">Java</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/java/" class="print-no-link">#Java</a></div></div><div class="license-box my-3"><div class="license-title"><div>浅谈 java中的 equals 和 hashcode</div><div>https://mritd.com/2016/02/02/java-equals-and-hashcode/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>Kovacs</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2016年2月2日</div></div><div class="license-meta-item"><div>许可协议</div><div><a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-by"></i> </span></a><a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><span class="hint--top hint--rounded" aria-label="NC - 非商业性使用"><i class="iconfont icon-nc"></i> </span></a><a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><span class="hint--top hint--rounded" aria-label="SA - 相同方式共享"><i class="iconfont icon-sa"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/2016/02/05/java-exception/" title="JAVA 异常处理"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">JAVA 异常处理</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/2016/01/24/redis-key-common-command/" title="Redis Key 常用命令"><span class="hidden-mobile">Redis Key 常用命令</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article id="comments" lazyload><div class="disqus" style="width:100%"><div id="disqus_thread"></div><script type="text/javascript">var disqus_config=function(){this.page.url="https://mritd.com/2016/02/02/java-equals-and-hashcode/",this.page.identifier="/2016/02/02/java-equals-and-hashcode/"};Fluid.utils.loadComments("#disqus_thread",(function(){var e=document,a=e.createElement("script");a.src="//bleem.disqus.com/embed.js",a.setAttribute("data-timestamp",new Date),(e.head||e.body).appendChild(a)}))</script><noscript>Please enable JavaScript to view the comments</noscript></div></article></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> <i class="iconfont icon-docker"></i> <a href="https://bandwagonhost.com/aff.php?aff=61367" target="_blank" rel="nofollow noopener"><span>BandwagonHost</span></a></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!0,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t,e){var i=Fluid.plugins.typing,n=e.getElementById("subtitle");n&&i&&i(n.getAttribute("data-typed-text"))}(window,document)</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js",(function(){var t=jQuery("#toc");if(0!==t.length&&window.tocbot){var i=jQuery("#board-ctn").offset().top;window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-i},CONFIG.toc)),t.find(".toc-list-item").length>0&&t.css("visibility","visible"),Fluid.events.registerRefreshCallback((function(){if("tocbot"in window){tocbot.refresh();var t=jQuery("#toc");if(0===t.length||!tocbot)return;t.find(".toc-list-item").length>0&&t.css("visibility","visible")}}))}}))</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js",(function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(o.join(", ")),Fluid.events.registerRefreshCallback((function(){if("anchors"in window){anchors.removeAll();var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(anchors.options.class="anchorjs-link-left"),anchors.add(o.join(", "))}}))}))</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",(function(){Fluid.plugins.fancyBox()}))</script><script>Fluid.plugins.imageCaption()</script><script src="/js/local-search.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript></body></html>