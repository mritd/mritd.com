

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/apple-touch-icon.png">
  <link rel="icon" type="image/png" href="/img/favicon.ico">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="Upward, not Northward.">
  <meta name="author" content="bleem">
  <meta name="keywords" content="漠然,bleem,mritd">
  <title>JDK8 新特性 - bleem</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/atom-one-dark.min.css" />
    
  

  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_pf9vaxs7x7b.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="bleem" type="application/atom+xml">
<link rel="alternate" href="/rss.xml" title="bleem" type="application/rss+xml">
</head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>bleem</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/friends/">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner intro-2" id="background" parallax=true
         style="background: url('/img/default.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container page-header text-center fade-in-up">
            <span class="h2" id="subtitle">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2006-01-02 15:04" pubdate>
        2006年1月2日 下午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      6.5k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      83
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto" id="post">
            <!-- SEO header -->
            <h1 style="display: none">JDK8 新特性</h1>
            
            <div class="markdown-body" id="post-body">
              <h2 id="一、接口的默认方法实现"><a href="#一、接口的默认方法实现" class="headerlink" title="一、接口的默认方法实现"></a>一、接口的默认方法实现</h2><p>在 JDK8 中，接口允许有默认的实现方法，这些默认的实现方法需要使用 <code>default</code> 关键字修饰即可，同时其实现类可直接调用这些方法；代码示例如下：</p>
<h3 id="1、自定义接口"><a href="#1、自定义接口" class="headerlink" title="1、自定义接口"></a>1、自定义接口</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">TestInterface</span> </span>&#123;

    <span class="hljs-comment">// 接口方法</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>;

    <span class="hljs-comment">// 接口默认方法1</span>
    <span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">defaultMethod1</span><span class="hljs-params">()</span></span>&#123;
        System.out.println(<span class="hljs-string">"Hello World!"</span>);
    &#125;

    <span class="hljs-comment">// 接口默认方法2</span>
    <span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">defaultMethod2</span><span class="hljs-params">()</span></span>&#123;
        System.out.println(<span class="hljs-string">"World Hello!"</span>);
    &#125;
&#125;</code></pre></div>



<h3 id="2、实现类及测试"><a href="#2、实现类及测试" class="headerlink" title="2、实现类及测试"></a>2、实现类及测试</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestInterfaceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">TestInterface</span> </span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">"Test 方法实现"</span>);
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        TestInterfaceImpl testInterface = <span class="hljs-keyword">new</span> TestInterfaceImpl();
        testInterface.test();

        <span class="hljs-comment">// default 修饰的默认方法可直接调用</span>
        testInterface.defaultMethod1();
        testInterface.defaultMethod2();
    &#125;
&#125;</code></pre></div>

<h3 id="3、默认方法的继承"><a href="#3、默认方法的继承" class="headerlink" title="3、默认方法的继承"></a>3、默认方法的继承</h3><p>同普通的类一样，接口的默认方法也可以被继承；而一旦被继承就会出现继承的顺序即优先级问题，接口的默认方法继承遵续以下几个原则：</p>
<ul>
<li>1、当某一个类实现了某一接口后，那么该类便继承了该接口的默认方法。</li>
<li>2、当某一个类实现某一接口，同时又继承另一个类，而另一个类中有一方法和接口中的默认方法相同，那么最终以类中的方法为准，即 <strong>类中的方法优先级高于接口中的方法。</strong></li>
<li>3、当某一类实现了两个接口，而两个接口中又有同方法签名的默认方法时，必须显示在该类中覆盖两个接口中的同方法签名的方法，否则编译不通过。</li>
<li>4、当某一类实现了两个接口，而其中一个接口的父接口，与另一个接口中的默认方法方法签名一致时，同样需要显示覆盖，否则编译报错。</li>
<li>5、当某一类实现了两个接口，而其中一个接口的父接口，与另一个接口中的默认方法方法签名一致，同时该接口又覆盖了父类的默认方法，此时也必须显式覆盖该方法，否则编译报错。</li>
</ul>
<h4 id="3-1、第2中情况测试-1省略"><a href="#3-1、第2中情况测试-1省略" class="headerlink" title="3.1、第2中情况测试(1省略)"></a>3.1、第2中情况测试(1省略)</h4><p><strong>有一默认方法的接口</strong></p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">TestIntefaceDefaultMethod</span> </span>&#123;

    <span class="hljs-comment">// 接口中的默认 test 方法</span>
    <span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;
        System.out.println(<span class="hljs-string">"TestIntefaceDefaultMethod"</span>);
    &#125;
&#125;</code></pre></div>

<p><strong>有一普通方法的父类</strong></p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestInterfaceDefaultMethodClazz</span> </span>&#123;

    <span class="hljs-comment">// 类中的 test 方法</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;
        System.out.println(<span class="hljs-string">"TestInterfaceDefaultMethodClazz"</span>);
    &#125;
&#125;</code></pre></div>

<p><strong>测试类，实现并继承上述接口和类</strong></p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// 继承一个类和一个接口</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">TestInterfaceDefaultMethodClazz</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">TestIntefaceDefaultMethod</span></span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        <span class="hljs-comment">// 打印 TestInterfaceDefaultMethodClazz</span>
        <span class="hljs-comment">// 说明调用的是类中的 test 方法</span>
        <span class="hljs-keyword">new</span> Test().test();
    &#125;
&#125;</code></pre></div>

<h4 id="3-2、第3中情况测试"><a href="#3-2、第3中情况测试" class="headerlink" title="3.2、第3中情况测试"></a>3.2、第3中情况测试</h4><p><strong>第一个有默认方法的接口</strong></p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">TestIntefaceDefaultMethod1</span> </span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;
        System.out.println(<span class="hljs-string">"TestIntefaceDefaultMethod1"</span>);
    &#125;
&#125;</code></pre></div>

<p><strong>第二个有默认方法的接口</strong></p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">TestIntefaceDefaultMethod2</span> </span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;
        System.out.println(<span class="hljs-string">"TestIntefaceDefaultMethod2"</span>);
    &#125;
&#125;</code></pre></div>

<p><strong>同时实现两个接口的测试类</strong></p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestExtendsInteface</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">TestIntefaceDefaultMethod1</span>,<span class="hljs-title">TestIntefaceDefaultMethod2</span></span>&#123;

    <span class="hljs-comment">// 必须显式覆盖 否则编译不通过</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-comment">// 在这里显式的调用要使用 哪个实现接口的方法</span>
        TestIntefaceDefaultMethod1.<span class="hljs-keyword">super</span>.test();
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        <span class="hljs-keyword">new</span> TestExtendsInteface().test();
    &#125;
&#125;</code></pre></div>

<h4 id="3-3、第4种情况测试"><a href="#3-3、第4种情况测试" class="headerlink" title="3.3、第4种情况测试"></a>3.3、第4种情况测试</h4><p><strong>TestIntefaceDefaultMethod1、TestIntefaceDefaultMethod2 接口与上面相同，新增一个 TestIntefaceDefaultMethod3 接口，该接口继承自 TestIntefaceDefaultMethod1，并且是一个空的接口</strong></p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">TestIntefaceDefaultMethod3</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">TestIntefaceDefaultMethod1</span></span>&#123;

&#125;</code></pre></div>

<p><strong>测试类同时实现 2、3两个接口，其中3接口继承1接口，并且为空接口</strong></p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestExtendsInteface</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">TestIntefaceDefaultMethod3</span>,<span class="hljs-title">TestIntefaceDefaultMethod2</span></span>&#123;

    <span class="hljs-comment">// 同样必须显式覆盖 否则编译报错</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-comment">// 在这里显式的调用要使用 哪个实现接口的方法</span>
        TestIntefaceDefaultMethod3.<span class="hljs-keyword">super</span>.test();
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        <span class="hljs-keyword">new</span> TestExtendsInteface().test();
    &#125;
&#125;</code></pre></div>

<h4 id="3-4、第5种情况"><a href="#3-4、第5种情况" class="headerlink" title="3.4、第5种情况"></a>3.4、第5种情况</h4><p><strong>TestIntefaceDefaultMethod3 覆盖了 TestIntefaceDefaultMethod1 的默认方法</strong></p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">TestIntefaceDefaultMethod3</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">TestIntefaceDefaultMethod1</span></span>&#123;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;
        System.out.println(<span class="hljs-string">"TestIntefaceDefaultMethod3"</span>);
    &#125;
&#125;</code></pre></div>

<p><strong>测试类</strong></p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestExtendsInteface</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">TestIntefaceDefaultMethod3</span>,<span class="hljs-title">TestIntefaceDefaultMethod2</span></span>&#123;

    <span class="hljs-comment">// 同样必须显式覆盖</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">"TestExtendsInteface"</span>);
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        <span class="hljs-keyword">new</span> TestExtendsInteface().test();
    &#125;
&#125;</code></pre></div>

<h4 id="3-5、总结"><a href="#3-5、总结" class="headerlink" title="3.5、总结"></a>3.5、总结</h4><p><strong>单接口实现情况下，默认方法可以直接用，多接口实现情况下一旦出现同方法签名的默认方法，那么必须显式覆盖，否则编译不通过。</strong></p>
<h2 id="二、接口的静态方法"><a href="#二、接口的静态方法" class="headerlink" title="二、接口的静态方法"></a>二、接口的静态方法</h2><p>JDK 8 中的接口允许使用静态的方法实现，如下所示：</p>
<p><strong>静态方法接口</strong></p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">TestStaticInterface</span> </span>&#123;
    <span class="hljs-comment">// 静态方法</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testStaticMethod</span><span class="hljs-params">()</span></span>&#123;
        System.out.println(<span class="hljs-string">"JDK8 Static Method!"</span>);
    &#125;
&#125;</code></pre></div>

<p><strong>测试类</strong></p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestStaticInterfaceImpl</span> </span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;

        <span class="hljs-comment">// 直接调用</span>
        TestStaticInterface.testStaticMethod();

    &#125;
&#125;</code></pre></div>

<h2 id="三、Lambda-表达式"><a href="#三、Lambda-表达式" class="headerlink" title="三、Lambda 表达式"></a>三、Lambda 表达式</h2><p>Lambda 表达式是 JDK8 新增的重要特性，Lambda 使 Java 具有了类似函数式编程的风格，其实 Lambda 表达式也是一个 “语法糖”，其实质也是由编译器根据表达式推断最终生成原始语法的字节码方式。</p>
<h3 id="1、基本语法"><a href="#1、基本语法" class="headerlink" title="1、基本语法"></a>1、基本语法</h3><p>Lambda 基本语法以 <code>(argument) -&gt; (body)</code> 表示，以下为具体的一些例子：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// 不需要参数，返回值为5</span>
() -&gt; <span class="hljs-number">5</span>
<span class="hljs-comment">// 接受一个 String 型的参数，返回值为 字符串+Hello World</span>
(String str) -&gt; str+<span class="hljs-string">" Hello World"</span>
<span class="hljs-comment">// 接受两个 int 型的参数，返回两数之和</span>
(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b) -&gt; a+b
<span class="hljs-comment">// 接受一个 String 型的参数，并将其打印到控制台，不反悔任何参数(void)</span>
(String str) -&gt; System.out.println(str)</code></pre></div>

<h3 id="2、Lambda-表达式结构"><a href="#2、Lambda-表达式结构" class="headerlink" title="2、Lambda 表达式结构"></a>2、Lambda 表达式结构</h3><ul>
<li>一个 Lambda 可以有零个或者多个参数；</li>
<li>参数类型可以声明，也可以由上下文推断，如 <code>(int a)</code> 与 <code>(a)</code> 效果一致；</li>
<li>所有参数包含在圆括号内，参数之间用分号分隔，如 <code>(int a,int b)</code> 或 <code>(a,b)</code>;</li>
<li>空圆括号代表参数集为空，如 <code>() -&gt; 2</code>；</li>
<li>当只有一个参数，且类型可被推倒时，圆括号可省略，如 <code>a -&gt; a+1</code>；</li>
<li>Lambda 表达式主体可包含一条或多条语句；</li>
<li>如果 Lamdba 表达式主体部分只有一条语句，那么花括号可以省略，同时匿名函数返回类型与该语句返回类型一致，如 <code>(int a,int b) -&gt; return a+b</code>；</li>
<li>如果 Lambda 表达式主体部分含有多条语句，则必须使用花括号，此时匿名函数返回类型与该代码块返回一致，没有返回则为空。</li>
</ul>
<h3 id="3、Lambda-表达式原理-函数式接口"><a href="#3、Lambda-表达式原理-函数式接口" class="headerlink" title="3、Lambda 表达式原理(函数式接口)"></a>3、Lambda 表达式原理(函数式接口)</h3><p>在 Java 中有两种描述层面的特殊接口：</p>
<p><strong>Marker(标记) 接口</strong>：这种接口内部不定义任何待实现的抽象方法，就像他的名字那样，只用作标记一个类，从而使其能够通过 <code>instanceof</code> 关键字检查。</p>
<p><strong>Function(函数) 接口</strong>：与标记接口不同的是，这种接口内部内有一个待实现的抽象方法，此种接口的作用是提供函数式编程需要，例如为 Lambda 表达式提供便利。</p>
<p><strong>其实每个 Lambda 表达式都隐式的赋值给了函数式接口，也就是说每个 Lambda 表达式其实都是函数式接口的内部抽象方法实现；</strong>从而我们便可以通过 Lambda 表达式来完成对函数式接口的简化操作，例如下面的 Runnable 接口：</p>
<div class="hljs"><pre><code class="hljs java">Runnable runnable = () -&gt; System.out.println(<span class="hljs-string">"Hello World"</span>);</code></pre></div>

<p><strong>当不指明 Lambda 表达式是哪个函数式接口的实现时，编译器还可以自动根据构造器将 Lambda 赋值给对应的函数式接口，</strong>如下：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestLambda</span> </span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        <span class="hljs-keyword">new</span> Thread(() -&gt; System.out.println(<span class="hljs-string">"Hello World!"</span>)).start();
    &#125;
&#125;</code></pre></div>

<p>以上代码，由于 <code>Thread</code> 类存在一个接受 <code>Runnable</code> 接口的构造器，而 <code>Runnable</code> 又是函数式接口，所以编译器自动推断将 Lambda 表达式隐式的赋值给了 <code>Runnable</code> 接口。</p>
<p><strong>注意：根据本人测试，当某个类有两个有参构造器，且两个有参构造器入参全部为函数式接口，同时该函数式接口返回值相同时，Lambda 表达式必须强制转换为其中一种类型，因为编译器无法推断出 Lambda 表达式到底是实现的那种函数式接口，测试代码如下：</strong></p>
<p><strong>两个函数式接口：Interface1、Interface2</strong></p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Interface1</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">()</span></span>;
&#125;</code></pre></div>

<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Interface2</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">()</span></span>;
&#125;</code></pre></div>

<p><strong>对应的使用类：TestLambdaInterface</strong></p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestLambdaInterface</span> </span>&#123;

    <span class="hljs-comment">// 两个有参构造器，参数都为函数式接口</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TestLambdaInterface</span> <span class="hljs-params">(Interface1 interface1)</span></span>&#123;
        interface1.sayHello();
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TestLambdaInterface</span> <span class="hljs-params">(Interface2 interface2)</span></span>&#123;
        interface2.sayHello();
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;

        <span class="hljs-comment">// 直接这么干是无法通过编译的</span>
        <span class="hljs-comment">// new TestLambdaInterface(() -&gt; System.out.println("Hello World!"));</span>

        <span class="hljs-comment">// 必须强制转换为某一具体接口类型</span>
        <span class="hljs-keyword">new</span> TestLambdaInterface((Interface1)() -&gt; System.out.println(<span class="hljs-string">"Hello World!"</span>));
    &#125;
&#125;</code></pre></div>

<h3 id="4、FunctionalInterface-注解"><a href="#4、FunctionalInterface-注解" class="headerlink" title="4、FunctionalInterface 注解"></a>4、FunctionalInterface 注解</h3><p>JDK 8 新增了 <code>FunctionalInterface</code> 注解，该注解只能作用在接口上，<strong>用于标注该接口是一个函数式接口；</strong>从而显式的告诉 Lambda 表达式将其赋值到此接口，这个注解标注了函数式接口，<strong>同时也限定了该接口内只能有一个抽象方法，</strong>否则将无法编译通过，示例如下：</p>
<p><strong>标注 @FunctionalInterface 注解的函数式接口</strong></p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">TestLambdaAnnotation</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">()</span></span>;
&#125;</code></pre></div>

<p><strong>测试使用类</strong></p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestLambdaAnnotationImpl</span> </span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TestLambdaAnnotationImpl</span><span class="hljs-params">(TestLambdaAnnotation lambdaAnnotation)</span></span>&#123;

    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        <span class="hljs-keyword">new</span> TestLambdaAnnotationImpl(() -&gt; System.out.println(<span class="hljs-string">"Hello World"</span>));
    &#125;
&#125;</code></pre></div>

<h3 id="5、Lambda-表达式作用域"><a href="#5、Lambda-表达式作用域" class="headerlink" title="5、Lambda 表达式作用域"></a>5、Lambda 表达式作用域</h3><p>Lambda 表达式和原来的匿名内部类相似，但在作用域等方面还有些细微差别：</p>
<h4 id="5-1、局部变量"><a href="#5-1、局部变量" class="headerlink" title="5.1、局部变量"></a>5.1、局部变量</h4><p>局部变量不必使用 <code>final</code> 关键字修饰，即可在 Lambda 表达式中直接使用，但是此后的该变量不可改变，相当于隐式 final，如下：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestLocalVariables</span> </span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;

        <span class="hljs-comment">// 不必声明为 final</span>
        <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;

        <span class="hljs-comment">// 直接使用</span>
        <span class="hljs-keyword">new</span> Thread(() -&gt; System.out.println(a)).start();

        <span class="hljs-comment">// 不可改变该变量,否则编译报错</span>
        <span class="hljs-comment">// a = 20;</span>
    &#125;
&#125;</code></pre></div>

<h4 id="5-2、对象属性与静态字段"><a href="#5-2、对象属性与静态字段" class="headerlink" title="5.2、对象属性与静态字段"></a>5.2、对象属性与静态字段</h4><p>同匿名对象一样，Lambda 表达式对于对象的属性和静态属性既可读又可写，如下：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestField</span> </span>&#123;

    <span class="hljs-comment">// 普通属性</span>
    String field = <span class="hljs-string">"Hello World"</span>;

    <span class="hljs-comment">// 静态属性</span>
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testScope</span><span class="hljs-params">()</span> </span>&#123;


        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;

            a =<span class="hljs-number">20</span>;
            System.out.println(a);

            field = <span class="hljs-string">"Test Scope"</span>;
            System.out.println(field);

        &#125;).start();
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        <span class="hljs-keyword">new</span> TestField().testScope();
    &#125;
&#125;</code></pre></div>

<h4 id="5-3、接口的默认方法"><a href="#5-3、接口的默认方法" class="headerlink" title="5.3、接口的默认方法"></a>5.3、接口的默认方法</h4><p>在普通的接口中，JDK8后新增的 default 关键字可实现让接口有其默认实现方法，外部接口对象不必实现，且可直接调用，然而在 Lambda 表达式中，不支持直接调用这些默认方法，如下：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestDefaultMethod</span> </span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;

        LambdaInterface lambdaInterface = () -&gt; System.out.println(<span class="hljs-string">"Hello"</span>);

        <span class="hljs-comment">// 以下代码无法通过编译</span>
        <span class="hljs-comment">// LambdaInterface lambdaInterface = () -&gt; testDeafaultMethod();</span>

    &#125;
&#125;</code></pre></div>

<h4 id="5-4、this-关键字"><a href="#5-4、this-关键字" class="headerlink" title="5.4、this 关键字"></a>5.4、this 关键字</h4><p>在内部类中，this 关键字指向当前内部类对象自己，而在 Lambda 表达式中，this 关键字指向的是 Lambda 表达式外部的类对象。</p>
<h3 id="6、Lambda-例子"><a href="#6、Lambda-例子" class="headerlink" title="6、Lambda 例子"></a>6、Lambda 例子</h3><p>以下为一个利用 Lambda 表达式简写 forEach 的例子：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestLambdaForEach</span> </span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;

        <span class="hljs-comment">// 首先创建一个待排序的 list</span>
        String str [] = &#123;<span class="hljs-string">"a"</span>,<span class="hljs-string">"b"</span>,<span class="hljs-string">"c"</span>,<span class="hljs-string">"d"</span>,<span class="hljs-string">"e"</span>&#125;;
        List&lt;String&gt; list = Arrays.asList(str);

        <span class="hljs-comment">// 原始的 forEach 遍历</span>
        <span class="hljs-keyword">for</span> (String strTmp:list) &#123;
            System.out.println(strTmp);
        &#125;

        <span class="hljs-comment">// Lambda 表达式遍历</span>
        list.forEach((String strTmp) -&gt; System.out.println(strTmp));

    &#125;
&#125;</code></pre></div>

<p>除了 forEach 外还可以简写 Thread，如下：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestLambdaThread</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        <span class="hljs-keyword">new</span> Thread(() -&gt; System.out.println(<span class="hljs-string">"Lambda Thread Test!"</span>)).start();
    &#125;
&#125;</code></pre></div>

<h2 id="四、方法引用"><a href="#四、方法引用" class="headerlink" title="四、方法引用"></a>四、方法引用</h2><p>Lambda 表达式提供了一种匿名方法实现，并允许我么以函数接口的形式使用它；对于已有的方法，JDK8 提供了 <strong>方法引用(Method references)</strong> 来实现同样的特性；方法引用并不需要提供方法体，而只需使用已有的方法名即可直接引用已存在的方法。</p>
<h3 id="1、方法引用替代-Lambda-表达式"><a href="#1、方法引用替代-Lambda-表达式" class="headerlink" title="1、方法引用替代 Lambda 表达式"></a>1、方法引用替代 Lambda 表达式</h3><p>以下为一个使用方法引用来替代 Lambda 表达式的例子：</p>
<p><strong>POJO</strong></p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Persion</span> </span>&#123;

    <span class="hljs-keyword">private</span> String name;
    <span class="hljs-comment">//省略 SET GET</span>
&#125;</code></pre></div>

<p><strong>一个函数接口</strong></p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">TestInterface</span> </span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">test</span><span class="hljs-params">(Persion persion)</span></span>;

&#125;</code></pre></div>

<p><strong>测试类</strong></p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestMethodReferences</span> </span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;

        <span class="hljs-comment">// 使用 Lambda 表达式</span>
        TestInterface testInterface = (persion) -&gt; persion.getName();

        <span class="hljs-comment">// 使用方法引用</span>
        TestInterface testInterface1 = Persion::getName;

    &#125;

&#125;</code></pre></div>

<h3 id="2、方法引用的种类"><a href="#2、方法引用的种类" class="headerlink" title="2、方法引用的种类"></a>2、方法引用的种类</h3><p>JDK 8中方法引用大致分为以下6种：</p>
<ul>
<li>静态方法引用 <code>ClassName::methodName</code></li>
<li>实例上的实例方法引用 <code>instanceReference::methodName</code></li>
<li>超类上的实例方法引用 <code>super::methodName</code></li>
<li>类型上的实例方法引用 <code>ClassName::methodName</code></li>
<li>构造方法引用 <code>Class::new</code></li>
<li>数组构造方法引用 <code>TypeName[]::new</code></li>
</ul>
<h3 id="3、方法引用与-Lambda-表达式"><a href="#3、方法引用与-Lambda-表达式" class="headerlink" title="3、方法引用与 Lambda 表达式"></a>3、方法引用与 Lambda 表达式</h3><p><strong>无论是方法引用还是 Lambda 表达式，其最终原理和所要实现的就是当某一个类中，或者接口中的某一方法，其入参为一个接口类型时，使用方法引用或者 Lambda 表达式可以快速而简洁的实现这个接口，而不必繁琐的创建一个这个接口的对象或者直接实现。</strong></p>
<p>参考文章：</p>
<ul>
<li><a href="http://news.oneapm.com/java-8-oneapm-lambda/" target="_blank" rel="noopener">http://news.oneapm.com/java-8-oneapm-lambda/</a></li>
<li><a href="https://blog.chou.it/2014/03/java-8-new-features/" target="_blank" rel="noopener">https://blog.chou.it/2014/03/java-8-new-features/</a></li>
<li><a href="http://www.cnblogs.com/figure9/p/java-8-lambdas-insideout-language-features.html" target="_blank" rel="noopener">http://www.cnblogs.com/figure9/p/java-8-lambdas-insideout-language-features.html</a></li>
</ul>
<h2 id="五、Stream-API"><a href="#五、Stream-API" class="headerlink" title="五、Stream API"></a>五、Stream API</h2><p>JDK 8 带来了强大的流式 API，用于简化集合操作；流式(Stream) API 配合 Lambda 表达式和方法引用 “可变身超级英雄”。</p>
<h3 id="1、Strean-API-简介"><a href="#1、Strean-API-简介" class="headerlink" title="1、Strean API 简介"></a>1、Strean API 简介</h3><p>新增的 <code>Stream API</code> 主要围绕 <code>java.util.stream</code> 包下的 <code>Stream</code> 类展开，Stream API 并非其语义上的 “流”，它不同于任何 I/O 流，实质上 <strong>Stream 可以看做是一个加强版 Iterator，不同的是 Stream 可以并行并高效的对集合进行 “神的” 奇操作</strong>，如下一个小例子：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test1</span> </span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;

        <span class="hljs-comment">// 首先创建一个待处理的 List</span>
        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
        list.add(<span class="hljs-number">1</span>);
        list.add(<span class="hljs-number">2</span>);
        list.add(<span class="hljs-number">3</span>);
        list.add(<span class="hljs-number">4</span>);

        <span class="hljs-comment">// 传统的过滤掉元素</span>

        <span class="hljs-comment">// 定义一个 ArrayList 用于存放结果</span>
        List resultList1 = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();

        <span class="hljs-comment">// 循环遍历</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> tmp:list) &#123;
            <span class="hljs-keyword">if</span> (tmp&lt;<span class="hljs-number">4</span>)&#123;
                resultList1.add(tmp);
            &#125;
        &#125;

        System.out.println(resultList1);


        <span class="hljs-comment">// Stream API + Lambda 过滤</span>

        <span class="hljs-comment">// 定义结果 List</span>
        List resultList2 = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();

        <span class="hljs-comment">// Stream+Lambda 操作</span>
        list.stream().filter((tmp) -&gt; tmp &lt;<span class="hljs-number">4</span>).forEach((result)-&gt; resultList2.add(result));

        System.out.println(resultList2);
    &#125;
&#125;</code></pre></div>

<h3 id="2、Stream-语法"><a href="#2、Stream-语法" class="headerlink" title="2、Stream 语法"></a>2、Stream 语法</h3><p>Stream 的大体语法如下：</p>
<p><img src="https://cdn.oss.link/markdown/hexo_java8_stream1.jpg" srcset="/img/loading.gif" alt="hexo_java8_stream1"></p>
<p>如上图所示，红色部分主要是创建一个 Stream，可以使从集合中创建或者选择其它方式，绿色部分代表对这个流的处理操作，可能是一个也可能是多个，比如连续 filter，<strong>每次操作后都可能返回处理后的流对象以便下次重复操作；</strong>最后的蓝色部分代表最终的 “汇聚” 动作，<strong>实质上中间部分对流做的各种动作不会立即执行，因为流不可逆性，无法重复操作，所以只有到最后的汇聚动作时才会一次执行到底。≈</strong></p>
<h3 id="3、创建-Stream"><a href="#3、创建-Stream" class="headerlink" title="3、创建 Stream"></a>3、创建 Stream</h3><p>创建一个 Stream 可以通过两种方式，一种是通过其静态工厂方法创建，另一种通过 <code>Collection</code> 接口默认方法创建；</p>
<h4 id="3-1、静态工厂创建-Stream"><a href="#3-1、静态工厂创建-Stream" class="headerlink" title="3.1、静态工厂创建 Stream"></a>3.1、静态工厂创建 Stream</h4><p>Stream 类中提供了三个静态工厂方法 <code>Stream.of()</code> 、 <code>Stream.generate()</code> 和 <code>Stream.iterate()</code> 来创建 Stream，其中 <code>Stream.of()</code> 有两个重载，一个接受固定长度的参数，一个接受可变长度的参数.</p>
<p><strong>Stream.of() 创建 Stream</strong></p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// 固定长度参数</span>
Stream&lt;String&gt; stream1 = Stream.of(<span class="hljs-string">"aa"</span>);

<span class="hljs-comment">// 可变长度参数</span>
Stream&lt;Integer&gt; stream2 = Stream.of(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>);</code></pre></div>

<p><strong>Stream.generate() 创建 Stream</strong></p>
<p><code>Stream.generate()</code> 方法用于生成一个无限长度的 Stream，其接受一个 <code>Supplier</code> 接口作为入参，该接口可看作是 Stream 内部元素的对象工厂，每次调用必须返回一个对象实例，测试如下：</p>
<div class="hljs"><pre><code class="hljs java">Stream stream3 = Stream.generate(() -&gt; <span class="hljs-keyword">new</span> Object());</code></pre></div>

<p><strong>Stream.iterate() 创建 Stream</strong></p>
<p>该方法同样用于创建一个无限长度的 Stream，不同的是 <code>iterate()</code> 方法接受两个参数，第一个参数可看作是一个种子，第二个参数可看作是一个方法，每次都会使用种子重复的执行方法，如下：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// 此代码将一直执行</span>
Stream.iterate(<span class="hljs-number">1</span>,(i) -&gt; i++).forEach((i)-&gt; System.out.println(i));</code></pre></div>

<h4 id="3-2、Collection-创建-Stream"><a href="#3-2、Collection-创建-Stream" class="headerlink" title="3.2、Collection 创建 Stream"></a>3.2、Collection 创建 Stream</h4><p>Collection 集合类的父接口提供了一个默认的方法 <code>ConllectionInstance.stream()</code> 来实现创建 Stream，所以直接使用或使用任意的 Collection 实现类即可创建 Stream，样例代码如下：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// 使用 ArrayList 创建</span>
Stream stream = <span class="hljs-keyword">new</span> ArrayList().stream();</code></pre></div>

<h3 id="4、转换Stream"><a href="#4、转换Stream" class="headerlink" title="4、转换Stream"></a>4、转换Stream</h3><p>对 Stream 每次操作后其实都会对其进行转换，从而返回一个新的 Stream，Stream 中定义了几个常用的转换方法如下：</p>
<h4 id="4-1、distinct-方法"><a href="#4-1、distinct-方法" class="headerlink" title="4.1、distinct 方法"></a>4.1、distinct 方法</h4><p>顾名思义，此方法将对 Stream 中的内容进行去重操作，<strong>注意，此操作依赖于 元素的 equals 方法，所以在对象去重时请重写 equals 和 hashcode 方法。</strong>此操作后新生成的 Stream 没有重复的元素，以下为测试代码：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// 创建一个 存放元素的 ArrayList</span>
List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();

list.add(<span class="hljs-string">"a"</span>);
list.add(<span class="hljs-string">"a"</span>);
list.add(<span class="hljs-string">"b"</span>);

<span class="hljs-comment">// 去重后的 list</span>
List list1 = list.stream().distinct().collect(Collectors.toList());

System.out.println(list1);</code></pre></div>

<h4 id="4-2、filter-方法"><a href="#4-2、filter-方法" class="headerlink" title="4.2、filter 方法"></a>4.2、filter 方法</h4><p>同样，从名字可以看出这是个过滤操作，通过 filter 方法可以过滤流，并返回一个新的 Stream，其中 filter 方法入参接受一个 Predicate 函数接口，可使用 Lambda 实现该函数接口，该接口主要作用是需要我们实现一个过滤条件；测试如下：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//创建一个元素 List</span>
List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();

list.add(<span class="hljs-number">1</span>);
list.add(<span class="hljs-number">2</span>);
list.add(<span class="hljs-number">3</span>);

<span class="hljs-comment">// 创建 Stream 并进行过滤</span>
List&lt;Integer&gt; list1 = list.stream().filter((i) -&gt; i&gt;<span class="hljs-number">1</span>).collect(Collectors.toList());

System.out.println(list1);</code></pre></div>

<h4 id="4-3、map-方法"><a href="#4-3、map-方法" class="headerlink" title="4.3、map 方法"></a>4.3、map 方法</h4><p>该方法从名字上看似乎与 Map 有关，实质上该方法主要作用是将 Stream 中的数据按照某种给定的转换策略进行转换，比如将 Stream 中的 字符串全部转化为 Integer 类型，map 方法同样接受一个函数接口，该接口需要我们实现为具体的转换策略，测试代码如下：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// 创建一个待转换的 List</span>
List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();

list.add(<span class="hljs-string">"1"</span>);
list.add(<span class="hljs-string">"2"</span>);
list.add(<span class="hljs-string">"3"</span>);

<span class="hljs-comment">// 获取 Stream 并转换</span>
List&lt;Integer&gt; list1 = list.stream().map((str) -&gt; Integer.parseInt(str)).collect(Collectors.toList());

System.out.println(list1);</code></pre></div>

<p><strong>map 方法有其精简版本，如 mapToInt，mapToLong和mapToDouble，从名字可以知道其作用。</strong></p>
<h4 id="4-4、flatMap-方法"><a href="#4-4、flatMap-方法" class="headerlink" title="4.4、flatMap 方法"></a>4.4、flatMap 方法</h4><p>flatMap 方法 和 map 方法类似，同样用于结果转换，但不同的是 flatMap 可以处理返回值为 Stream 的处理，如下面的样例：</p>
<p><strong>使用 map 的处理情况</strong></p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestFlatMap</span> </span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;

        <span class="hljs-comment">// 创建元素集合</span>
        List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();

        list.add(<span class="hljs-string">"123"</span>);
        list.add(<span class="hljs-string">"456"</span>);
        list.add(<span class="hljs-string">"789"</span>);

        <span class="hljs-comment">// 创建流并转换   此处将返回一个套嵌流</span>
        Stream&lt;Stream&lt;Character&gt;&gt; stream = list.stream().map(TestFlatMap::toCharterStream);

        <span class="hljs-comment">// 获取这个 套嵌流中所有内容</span>
        stream.forEach((streamTmp) -&gt; streamTmp.forEach((c) -&gt; System.out.println(c)));

    &#125;


    <span class="hljs-comment">// 字符串分解 并返回 Charcater 的 Stream</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Stream&lt;Character&gt; <span class="hljs-title">toCharterStream</span><span class="hljs-params">(String s)</span></span>&#123;

        <span class="hljs-comment">// 缓存结果</span>
        List&lt;Character&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c: s.toCharArray()) &#123;
            <span class="hljs-comment">// 将每一个字符串分解为 char 放入缓存结果中</span>
            list.add(Character.valueOf(c));
        &#125;

        <span class="hljs-comment">// 返回 一个 Character 的 Stream</span>
        <span class="hljs-keyword">return</span> list.stream();
    &#125;
&#125;</code></pre></div>

<p><strong>从上面可以看出，当转换方法返回另一个流即套嵌流 <code>Stream&lt;Stream&gt;</code> 时，我们想获取 Stream 中所有内容极其困难和复杂，而 flatMap 方法很好的解决了这个问题：</strong></p>
<p><strong>flatmap 实现</strong></p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestFlatMap1</span> </span>&#123;


    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;

        <span class="hljs-comment">// 创建元素集合</span>
        List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();

        list.add(<span class="hljs-string">"123"</span>);
        list.add(<span class="hljs-string">"456"</span>);
        list.add(<span class="hljs-string">"789"</span>);


        <span class="hljs-comment">// 注意 此处套嵌流自动被合并</span>
        Stream&lt;Character&gt; stream = list.stream().flatMap(TestFlatMap1::toCharterStream);

        stream.forEach((c) -&gt; System.out.println(c));

    &#125;


    <span class="hljs-comment">// 字符串分解 并返回 Charcater 的 Stream</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Stream&lt;Character&gt; <span class="hljs-title">toCharterStream</span><span class="hljs-params">(String s)</span> </span>&#123;

        <span class="hljs-comment">// 缓存结果</span>
        List&lt;Character&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : s.toCharArray()) &#123;
            <span class="hljs-comment">// 将每一个字符串分解为 char 放入缓存结果中</span>
            list.add(Character.valueOf(c));
        &#125;

        <span class="hljs-comment">// 返回 一个 Character 的 Stream</span>
        <span class="hljs-keyword">return</span> list.stream();
    &#125;
&#125;</code></pre></div>

<p><strong>总结：map 方法在实现的转换方法返回 Stream 时，会形成套嵌 <code>Stream&lt;Stream&gt;</code>，当要遍历时极其困难，而 flatMap 方法则会自动合并套嵌流。</strong></p>
<h4 id="4-5、peek-方法"><a href="#4-5、peek-方法" class="headerlink" title="4.5、peek 方法"></a>4.5、peek 方法</h4><p>peek 方法用于对 Stream 内元素进行包装，即在外面包装一层我们自定义的方法，当 Stream 内元素被消费(处理/转化)时，则触发该方法执行，如下测试例子：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestPeek</span> </span>&#123;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;

        <span class="hljs-comment">// peek 包装时自定义了一个 输出方法,当每次 map 方法对元素转换(消费)时,都会触发 该方法执行</span>
        Stream.of(<span class="hljs-string">"1"</span>,<span class="hljs-string">"2"</span>,<span class="hljs-string">"3"</span>)
                .peek((s) -&gt; System.out.println(<span class="hljs-string">"元素被消费: "</span>+s))
                .map((s) -&gt; Integer.parseInt(s))
                .collect(Collectors.toList());
    &#125;
&#125;</code></pre></div>

<h4 id="4-6、limit-方法"><a href="#4-6、limit-方法" class="headerlink" title="4.6、limit 方法"></a>4.6、limit 方法</h4><p>顾名思义，此方法将对 Stream 内元素进行截断操作，返回的 Stream 中包含截断后的元素，<strong>注意此方法向后截断，即语义为 “保留前面的 N 个元素”；</strong>测试如下：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// 截断操作</span>
List&lt;Integer&gt; list = Stream.of(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>).limit(<span class="hljs-number">3</span>).collect(Collectors.toList());

<span class="hljs-comment">// 打印 [1, 2, 3]</span>
System.out.println(list);</code></pre></div>

<h4 id="4-7、skip-方法"><a href="#4-7、skip-方法" class="headerlink" title="4.7、skip 方法"></a>4.7、skip 方法</h4><p>skip 方法与 limit 正好相反，<strong>语义为：丢弃前 N 个元素</strong>；测试如下：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// 打印 3,4,5</span>
Stream.of(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>).skip(<span class="hljs-number">2</span>).forEach((i)-&gt; System.out.println(i));</code></pre></div>

<h3 id="5、汇聚-折叠"><a href="#5、汇聚-折叠" class="headerlink" title="5、汇聚(折叠)"></a>5、汇聚(折叠)</h3><p>汇聚也成折叠，当对一个流进行各种操作后(filter、map等)，实际上该流并不会立即被处理，因为流只能流向性的一次走完，只有在最后进行汇聚(折叠)动作时，该流才会一直被转换/处理完成并最终返回一个新的流。</p>
<p><strong>汇聚一般分为两种：</strong></p>
<p><strong>可变汇聚：</strong>把输入的元素累积到一个可变容器中，比如 Collection或者 StringBuilder。<br><strong>其他汇聚：</strong>其他汇聚即除了可变汇聚之外的都称作其他汇聚，一般这些汇聚都是反复操作结果流，并通过前一次的结果流当做下一次的入参，最终形成一个结果，如 reduce，count，allMatch等。</p>
<h4 id="5-1、可变汇聚"><a href="#5-1、可变汇聚" class="headerlink" title="5.1、可变汇聚"></a>5.1、可变汇聚</h4><p>可变汇聚对应的只有一个方法 <code>Stream.collect()</code>，该方法将流中处理后的元素汇聚到一个 容器中，比如 <code>Collection</code>；<strong>注意，Stream API 中对流处理操作并不会改变原有容器，比图 List.stream() 返回的流无论怎么处理，原来的 List 都不会受影响。</strong></p>
<h5 id="5-1-1、默认的-collect-方法"><a href="#5-1-1、默认的-collect-方法" class="headerlink" title="5.1.1、默认的 collect 方法"></a>5.1.1、默认的 collect 方法</h5><p>查看 collect 方法如下：</p>
<div class="hljs"><pre><code class="hljs java">&lt;R&gt; <span class="hljs-function">R <span class="hljs-title">collect</span><span class="hljs-params">(Supplier&lt;R&gt; supplier,</span></span>
<span class="hljs-function"><span class="hljs-params">      BiConsumer&lt;R, ? <span class="hljs-keyword">super</span> T&gt; accumulator,</span></span>
<span class="hljs-function"><span class="hljs-params">      BiConsumer&lt;R, R&gt; combiner)</span></span>;</code></pre></div>

<p>Supplier supplier是一个工厂函数，用来生成一个新的容器；BiConsumer accumulator也是一个函数，用来把Stream中的元素添加到结果容器中；BiConsumer combiner还是一个函数，用来把中间状态的多个结果容器合并成为一个（并发的时候会用到），下面举个栗子：</p>
<div class="hljs"><pre><code class="hljs java">List result = Stream.of(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>).filter((i) -&gt; i&gt;<span class="hljs-number">1</span>).
                collect(() -&gt; <span class="hljs-keyword">new</span> ArrayList(),
                        (list,i) -&gt; list.add(i),
                        (listAll,list) -&gt; listAll.addAll(list));

System.out.println(result);</code></pre></div>

<p><strong>第一个参数用于生成一个容器(ArrayList),第二个参数用于将 Stream 中的元素加入到前面生成的容器(list)中，第三个参数在并发时，用于将</strong></p>
<h5 id="5-1-2、collect-简化版本"><a href="#5-1-2、collect-简化版本" class="headerlink" title="5.1.2、collect 简化版本"></a>5.1.2、collect 简化版本</h5><p>clooect 还有一个 override 版本，如下：</p>
<div class="hljs"><pre><code class="hljs java">&lt;R, A&gt; <span class="hljs-function">R <span class="hljs-title">collect</span><span class="hljs-params">(Collector&lt;? <span class="hljs-keyword">super</span> T, A, R&gt; collector)</span></span>;</code></pre></div>

<p>从上面可以看出，该方法接受一个 <code>Collector</code> 接口，JDK 8 为我们提供了快速创建该接口的工具类 <code>java.util.stream.Collectors</code>，其中调用该工具类的方法可以快速创建 <code>Collector</code> 接口的实力，典型的方法有 <code>Collectors.toList()</code>、<code>Collectors.toSet()</code>、<code>Collectors.toCollection()</code> 等等，具体可自行查看源码，从名字也很容易看出其用途，如下是一个汇聚到 List 的代码示例：</p>
<div class="hljs"><pre><code class="hljs java">List result = Stream.of(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>).filter((i) -&gt; i&gt;<span class="hljs-number">1</span>).collect(Collectors.toList());</code></pre></div>

<h4 id="5-2、其他汇聚"><a href="#5-2、其他汇聚" class="headerlink" title="5.2、其他汇聚"></a>5.2、其他汇聚</h4><h5 id="5-2-1、reduce-方法"><a href="#5-2-1、reduce-方法" class="headerlink" title="5.2.1、reduce 方法"></a>5.2.1、reduce 方法</h5><p>reduce 方法用于迭代累加操作，该方法有三种 override 版本，第一种结构如下：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function">Optional&lt;T&gt; <span class="hljs-title">reduce</span><span class="hljs-params">(BinaryOperator&lt;T&gt; accumulator)</span></span>;</code></pre></div>

<p>同样该方法接受一个 BinaryOperator 接口对象，BinaryOperator 接口对象用于实现 “累加动作”，即以何种方式累加；该接口接受两个参数，第一个参数为上次操作结果的临时变量，第二个参数为 Stream 中的元素，测试代码如下：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// int 累加</span>
<span class="hljs-keyword">int</span> test1 = Stream.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>).filter((i) -&gt; i &gt; <span class="hljs-number">1</span>).reduce((result, filed) -&gt; result + filed).get();

<span class="hljs-comment">// String 累加</span>
String test2 = Stream.of(<span class="hljs-string">"He"</span>,<span class="hljs-string">"llo"</span>,<span class="hljs-string">" "</span>,<span class="hljs-string">"Wo"</span>,<span class="hljs-string">"rld"</span>).reduce((result,filed) -&gt; result+filed).get();

System.out.println(test1);
System.out.println(test2);</code></pre></div>

<p>该方法的第二种结构如下：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function">T <span class="hljs-title">reduce</span><span class="hljs-params">(T identity, BinaryOperator&lt;T&gt; accumulator)</span></span>;</code></pre></div>

<p><strong>注意，该版本返回值直接就是一个具体的数据类型，这个数据类型可以根据传入的初始值 <code>identity</code> 进行推断出来。</strong></p>
<p>此时第一个参数为一个初始值，后面的累加操作基于这个初始值，如果 Stream 为空那么将直接返回初始值，第二个参数同样为累加算法，测试代码如下：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// 带有初始值的累加</span>
String test3 = Stream.of(<span class="hljs-string">"llo"</span>,<span class="hljs-string">" "</span>,<span class="hljs-string">"Wo"</span>,<span class="hljs-string">"rld"</span>).reduce(<span class="hljs-string">"He"</span>,(result,filed) -&gt; result+filed);

System.out.println(test3);</code></pre></div>

<h5 id="5-2-2、count-方法"><a href="#5-2-2、count-方法" class="headerlink" title="5.2.2、count 方法"></a>5.2.2、count 方法</h5><p>count 方法用于统计元素个数，测试代码如下：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// 注意返回值为long 类型</span>
<span class="hljs-keyword">long</span> count = Stream.of(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>).count();
System.out.println(count);</code></pre></div>

<h5 id="5-2-3、其他方法"><a href="#5-2-3、其他方法" class="headerlink" title="5.2.3、其他方法"></a>5.2.3、其他方法</h5><ul>
<li>allMatch 方法用于检测结果中是否都满足某一条件，测试如下：</li>
</ul>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">boolean</span> flag = Stream.of(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>).allMatch((i) -&gt; i&gt;<span class="hljs-number">0</span>);
System.out.println(flag);</code></pre></div>

<p><strong>其他方法基本一致，代码就不写了</strong></p>
<ul>
<li>anyMatch：Stream中是否存在任何一个元素满足匹配条件</li>
<li>findFirst：返回Stream中的第一个元素，如果Stream为空，返回空Optional</li>
<li>noneMatch：是不是Stream中的所有元素都不满足给定的匹配条件</li>
<li>max和min：使用给定的比较器(Operator)，返回Stream中的最大/最小值。</li>
</ul>
<p>Stream API  参考自 <a href="http://ifeve.com/stream/" target="_blank" rel="noopener">Java8初体验（二）Stream语法详解</a></p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/java/">Java</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/java/">Java</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a rel="license noopener" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 国际许可协议进行许可，转载请注明出处。</p>
              
              
                <div class="post-prevnext row">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2006/01/02/jaxb-note/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">JAXB 笔记</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2006/01/02/jvm-object-determination-and-reclaimable-algorithm/">
                        <span class="hidden-mobile">JVM 对象判定和可回收算法</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments">
                
                
  <div class="disqus" style="width:100%">
    <div id="disqus_thread"></div>
    <script type="text/javascript">
      var disqus_config = function () {
        this.page.url = 'https://mritd.com/2006/01/02/jdk8-new-features/';
        this.page.identifier = '/2006/01/02/jdk8-new-features/';
      };
      function loadDisqus() {
        (function () {
          var d = document,
            s = d.createElement('script');
          s.src = '//' + 'mritd' + '.disqus.com/embed.js';
          s.setAttribute('data-timestamp', new Date());
          (d.head || d.body).appendChild(s);
        })();
      }
      waitElementVisible('disqus_thread', loadDisqus);
    </script>
    <noscript>Please enable JavaScript to view the
      <a href="https://disqus.com/?ref_noscript" target="_blank" rel="nofollow noopener noopener">comments powered by Disqus.</a>
    </noscript>
  </div>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener">
        <span>Fluid</span></a>
    </div>
    

    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/main.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>







  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: '#post-body',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 3,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "JDK8 新特性&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 80,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
      icon: "❡"
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>




















</body>
</html>
