

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/apple-touch-icon.png">
  <link rel="icon" type="image/png" href="/img/favicon.ico">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="Upward, not Northward.">
  <meta name="author" content="bleem">
  <meta name="keywords" content="漠然,bleem,mritd">
  <title>浅谈 java中的 equals 和 hashcode - bleem</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/atom-one-dark.min.css" />
    
  

  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_pf9vaxs7x7b.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="bleem" type="application/atom+xml">
<link rel="alternate" href="/rss.xml" title="bleem" type="application/rss+xml">
</head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>bleem</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/friends/">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner intro-2" id="background" parallax=true
         style="background: url('/img/default.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container page-header text-center fade-in-up">
            <span class="h2" id="subtitle">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2006-01-02 15:04" pubdate>
        2006年1月2日 下午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      2.8k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      31
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto" id="post">
            <!-- SEO header -->
            <h1 style="display: none">浅谈 java中的 equals 和 hashcode</h1>
            
            <div class="markdown-body" id="post-body">
              <p><img src="https://cdn.oss.link/markdown/hexo_java_equals_hashcode.jpg" srcset="/img/loading.gif" alt="hexo_java_equals_hashcode.jpg"></p>
<h2 id="equals-方法"><a href="#equals-方法" class="headerlink" title="equals 方法"></a>equals 方法</h2><blockquote>
<p>equals 方法来源于 Object 超类；该方法用于检测一个对象与另一个对象是否相等。</p>
</blockquote>
<h3 id="Object-中的-equals"><a href="#Object-中的-equals" class="headerlink" title="Object 中的 equals"></a>Object 中的 equals</h3><blockquote>
<p>在 java 源码中，Object 的 equals 实现如下</p>
</blockquote>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object obj)</span> </span>&#123;
    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span> == obj);
&#125;</code></pre></div>



<blockquote>
<p>由此可见，Object 中 equals 默认比较的是两个对象的 内存地址(==)，即 <strong>默认比较两个对象的引用，引用相同返回true，反之返回false。</strong>这看起来似乎合情合理，但实际开发中，这种比较方式则不适用；比如我们要比较两个 pserson 对象是否相等，<strong>从业务角度来说，只要这两个人 名字、年龄、身份证号相同，我们就可以认为两个对象相等。但由于是两个 pserson对象，所以所以引用肯定不同，这样调用默认的 equals 方法就会返回 false，显然是不合理的。</strong></p>
</blockquote>
<h3 id="重写-equals"><a href="#重写-equals" class="headerlink" title="重写 equals"></a>重写 equals</h3><blockquote>
<p>从上面的例子可以看出，Object 中的 equals 并不适用与实际业务场景，此时我们应该 对 equals进行重写；但是 重写 equals 必须满足以下规则(特性)：</p>
</blockquote>
<ul>
<li><p>自反性</p>
<blockquote>
<p>对于对象 x ，<code>x.equals(x)</code> 应当始终返回 true。</p>
</blockquote>
</li>
<li><p>对称性</p>
<blockquote>
<p>对于对象 x、y，如果 <code>x.equals(y)</code> 返回 true，那么 <code>y.equals(x)</code> 也必须返回 true。</p>
</blockquote>
</li>
<li><p>传递性</p>
<blockquote>
<p>对于对象 x、y、z，如果 <code>x.equals(y)</code> 返回 true，<code>y.equals(z)</code> 返回 true；那么 <code>x.equals(z)</code> 也必须返回 true。</p>
</blockquote>
</li>
<li><p>一致性</p>
<blockquote>
<p>对于对象 x、y，如果 <code>x.equals(y)</code> 返回 true，那么反复调用的结果应当一直为 true。</p>
</blockquote>
</li>
<li><p>空值不行等性</p>
<blockquote>
<p>对于任意非空对象 x，<code>x.equals(null)</code> 应当永远返回 false。</p>
</blockquote>
</li>
</ul>
<hr>
<p><strong>然而，对于以上5种特性，在某些特殊情况下需要严格考虑。</strong></p>
<ul>
<li>对象属性的冲突</li>
</ul>
<p>假设我们将对象内的属性看作是对象内容，在实际业务场景，可能一个 汽车 Car 对象 和一个人 pserson 对象具有相同的名字，比如 <code>特斯拉</code>；此时如果我们重写 equals 时仅仅比较对象内容的话，很可能误判为 <strong>一辆汽车和一个人相等</strong>；是的，这很滑稽。</p>
<h3 id="getClass-的使用"><a href="#getClass-的使用" class="headerlink" title="getClass 的使用"></a>getClass 的使用</h3><p>在上面列举的情况来看，我们似乎再重写 equals 时还需要考虑对象的类型；在 java 里，对象类型我们 采用 Class 描述。那么此时 我们在重写的 equals 方法里应当 增加 <code>car.getClass()==pserson.getClass()</code> 的检测，这样能有效避免上述情况的发生；伪代码如下</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object obj)</span></span>&#123;
    <span class="hljs-comment">// 进行完全匹配检测(引用)</span>
    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>==obj) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
    <span class="hljs-comment">// 进行空值检测</span>
    <span class="hljs-keyword">if</span>(obj==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
    <span class="hljs-comment">// 进行类型匹配检测</span>
    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.getClass()!=obj.getClass()) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
    <span class="hljs-comment">// 进行属性相等检测，省略...</span>
&#125;</code></pre></div>

<h3 id="instanceof-的使用"><a href="#instanceof-的使用" class="headerlink" title="instanceof 的使用"></a>instanceof 的使用</h3><p>然而，即使我们考虑了属性相等的情况，我们还是忽略了很多其他的业务场合。比如 一个学生 Student 对象和一个人 pserson 对象；当使用上面的检测方法时，很明显 pserson 对象和 Student 对象的 Class 不一致，直接返回了 false；而实际业务场景是 一个 Student 对象也是一个人 pserson；<strong>Student 对象可能继承于pserson对象。</strong>而此时我们应当使用 instanceof 进行检测，伪代码如下：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object obj)</span></span>&#123;
    <span class="hljs-comment">// 进行完全匹配检测(引用)</span>
    <span class="hljs-keyword">if</span>(!(<span class="hljs-keyword">this</span> instaceof obj)) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
    <span class="hljs-comment">// 进行空值检测</span>
    <span class="hljs-keyword">if</span>(obj==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
    <span class="hljs-comment">// 进行类型匹配检测</span>
    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.getClass()!=obj.getClass()) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
    <span class="hljs-comment">// 进行属性相等检测，省略...</span>
&#125;</code></pre></div>

<h3 id="getClass-与-instaceof-的取舍"><a href="#getClass-与-instaceof-的取舍" class="headerlink" title="getClass 与 instaceof 的取舍"></a>getClass 与 instaceof 的取舍</h3><p>或许从上两个例子中我们感觉使用 instaceof 更 “靠谱一些”；但其实我们注意到，<strong>采用 instaceof 检测实际上违反了 <code>对称性</code> 原则；</strong> 因为 <code>pserson instaceof Student</code> 返回 false，反之返回 true。</p>
<p>所以对于 <code>instanceof</code> 有时候并不那么完美；就连 JDK的开发者也遇到了这个问题；在 <code>Timestamp</code> 类中，由于继承自 <code>java.util.Date</code>；而不幸的是 Date 类的 equals 采用的是 instanceof，这就导致对称性出了问题。从上可知，我们根据实际业务进行取舍，取舍原则如下：</p>
<ul>
<li>如果子类拥有自己的相等性概念，则对称性强制要求采用 getClass 方式检测。</li>
<li>如果由超类决定相等性概念，那么就可以采用 instanceof 检测，保证我们可以在子类对象间进行相等性判断。</li>
</ul>
<h3 id="重写-equals-的建议"><a href="#重写-equals-的建议" class="headerlink" title="重写 equals 的建议"></a>重写 equals 的建议</h3><ul>
<li>首先检测 this 与 otherObject 是否引用同一对象</li>
</ul>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>==otherObject) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</code></pre></div>

<ul>
<li>然后检测 otherObject是否为 null，如果为 null 返回 false，这是必须的</li>
</ul>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(otherObject == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</code></pre></div>

<ul>
<li>其次比较 this 与 otherObject 是否同属于一个类；如果 equals 语义在子类中有所改变，则 使用 getClass 检测</li>
</ul>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.getClass()!=otherObject.getClass()) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</code></pre></div>

<ul>
<li>最后将 otherObject强制转换为 当前类型，并进行属性值检测；注意：<strong>如果在子类中重写的equals，则需要在重写时首先进行 <code>super.equals(other)</code> 判断</strong></li>
</ul>
<h2 id="hashcode-方法"><a href="#hashcode-方法" class="headerlink" title="hashcode 方法"></a>hashcode 方法</h2><blockquote>
<p>写这篇博客之前，也看过很多博客，大部分大家写的都是这样的一句话：<strong>重写 equals 必须重写 hashcode，两个对象 equals 返回 true 则 hashcode 必须保证相同。</strong>但是，接下来就没有然后了；搞的我刚学 java 时候也挺晕的，就像是 “知其然而不知所以然”。</p>
</blockquote>
<blockquote>
<p>总结一下一般会有这几个问题：</p>
</blockquote>
<ul>
<li>hashcode 方法是干啥的？</li>
<li>hashcode(哈希值) 是个什么玩意？</li>
<li>hashcode 有什么用？</li>
<li>我为啥要重写 hashcode？</li>
<li>我不重写它有啥后果？</li>
</ul>
<h3 id="hashcode-方法是干啥的？"><a href="#hashcode-方法是干啥的？" class="headerlink" title="hashcode 方法是干啥的？"></a>hashcode 方法是干啥的？</h3><blockquote>
<p>官方的解释是这样的：<strong>hashcode 方法用于返回一个对象的 哈希值。</strong>说白了就是 hashcode 方法能返回一个 哈希值，这玩意是个整数。</p>
</blockquote>
<h3 id="hashcode-哈希值-是个什么玩意？"><a href="#hashcode-哈希值-是个什么玩意？" class="headerlink" title="hashcode(哈希值) 是个什么玩意？"></a>hashcode(哈希值) 是个什么玩意？</h3><blockquote>
<p>由上面可知，这个 哈希值就是一个整数，可能是正数也可能是负数。</p>
</blockquote>
<h3 id="hashcode-有什么用？"><a href="#hashcode-有什么用？" class="headerlink" title="hashcode 有什么用？"></a>hashcode 有什么用？</h3><blockquote>
<p>hashcode(哈希值) 的作用就是用于在使用 Hash算法实现的集合中确定元素位置。</p>
</blockquote>
<p>拿我们最常见的 HashMap 来说，我们都知道 HashMap 里通过 key 取 value 时的速度 是 O(1) 级别的；</p>
<p>什么是 O(1)级别？</p>
<p>O(1)级别说白了就是 <strong>在任意数据大小的容器中，取出一个元素所使用的时间与元素个数无关；通俗的说法就是 不论你这个 HashMap 里有100个元素还是有9999999个元素，我通过 key 取出一个元素所使用的时间是一样的。</strong></p>
<p>为何是 O(1) 级别？为何这么吊？</p>
<p>这个问题就要谈一下 HashMap 等 hash 容器的存储方式了；这些容器在存储元素是是这样的：首先获取你要存储元素的 hashcode(一个整数)，然后再定义一个固定整数(标准叫桶数)，最后用 hashcode 对 另一个整数(桶数) 取余；取余的结果即为元素要存储的下标(可能存放到数组里)。当然这里是简单的取余，可能更复杂。</p>
<p>当我们要从一个 HashMap 中取出一个 value 时，实际上他就是通过这套算法，用 key 的 hashcode 计算出元素位置，直接取出来了；所以说 无论你这里面有多少元素，它取的时候始终是用着一个算法、一个流程，不会因为你数据多少而产生影响，这就是 O(1) 级别的存储。</p>
<p><strong>总结：由上面可知，这个 hashcode 的作用就是 通过算法来确立元素存放的位置，以便于放入元素或者获取元素。</strong></p>
<h3 id="我为啥要重写-hashcode-amp-amp-不重写有啥后果"><a href="#我为啥要重写-hashcode-amp-amp-不重写有啥后果" class="headerlink" title="我为啥要重写 hashcode &amp;&amp; 不重写有啥后果"></a>我为啥要重写 hashcode &amp;&amp; 不重写有啥后果</h3><blockquote>
<p>回顾一下上面：hashcode 是个整数，hashcode 方法的作用就是计算并返回这个整数；这个整数用于存放 Hash 算法实现的容器时 确定元素位置。</p>
</blockquote>
<p>接下来考虑一个业务场景：有两个对象 pserson1 和 pserson2 ，pserson1 和 pserson2 都只有两个属性，分别是名字(name)和年龄(age)。现在 pserson1 和 pserson2 的名字(name)、年龄(age) 都相同；那么我们是否可以根据业务场景来说 <strong>pserson1 和 pserson2 是同一个人</strong>？</p>
<p>如果说 “是” 的话，我们刚刚所认为的 “从业务角度理解 pserson1 和 pserson2 是一个人” 是不是就相当于 重写了 Pserson 的 equals 方法呢？就像下面这样：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pserson</span> </span>&#123;
	<span class="hljs-keyword">private</span> String name;
	<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;

	<span class="hljs-comment">// 重写 equals</span>
	<span class="hljs-meta">@Override</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object obj)</span> </span>&#123;
		<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == obj)
			<span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
		<span class="hljs-keyword">if</span> (obj == <span class="hljs-keyword">null</span>)
			<span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
		<span class="hljs-keyword">if</span> (getClass() != obj.getClass())
			<span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;

		<span class="hljs-comment">// 主要在这，我们根据业务逻辑，即 姓名和年龄 确立相等关系</span>
		pserson other = (pserson) obj;
		<span class="hljs-keyword">if</span> (age != other.age)
			<span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
		<span class="hljs-keyword">if</span> (name == <span class="hljs-keyword">null</span>) &#123;
			<span class="hljs-keyword">if</span> (other.name != <span class="hljs-keyword">null</span>)
				<span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
		&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!name.equals(other.name))
			<span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
	&#125;
&#125;</code></pre></div>

<p>我们注意到，我们根据业务逻辑重写 equals 后，造成的结果就是，两个 属性相同的 Pserson 对象 我们就认为是相同的，即 equals 返回了 true；<br><strong>但我们没有重写 hashcode，Object 中的 hashcode 是 native(本地的)，也就是很可能不同对象返回不同的 hashcode，即使属性相同也没用。</strong></p>
<hr>
<p>到这里我们再总结一下：</p>
<ul>
<li><strong>hashcode 方法返回对象的 哈希值；</strong></li>
<li><strong>我们通过 哈希值 的运算(与指定数取余等)来确立元素在 hash 算法实现的容器中的位置；</strong></li>
<li><strong>Object 中的 hashcode 方法 对于业务逻辑上相等的两个对象(属性相同，不同引用) 返回的 hashcode 是不同的。</strong></li>
</ul>
<hr>
<p><strong>墨迹了那么多最终问题来了：假设我们只重写了 pserson 的 equals 方法，使之 “属性相同即为相等”，当我们把两个 “相等的(属性相同的)” Pserson 对象 放入 HashSet 中会怎样？</strong></p>
<p>友情提示：HashSet中默认是不许放重复元素的，放重复的是会被过滤掉的，如下代码所示：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test1</span> </span>&#123;
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
		Pserson pserson1 = <span class="hljs-keyword">new</span> Pserson();
		pserson1.setName(<span class="hljs-string">"张三"</span>);
		pserson1.setAge(<span class="hljs-number">10</span>);

		Pserson pserson2 = <span class="hljs-keyword">new</span> Pserson();
		pserson2.setName(<span class="hljs-string">"张三"</span>);
		pserson2.setAge(<span class="hljs-number">10</span>);

		HashSet&lt;Pserson&gt; hashSet = <span class="hljs-keyword">new</span> HashSet&lt;Pserson&gt;();

		hashSet.add(pserson1);
		hashSet.add(pserson2);

		System.out.println(hashSet.size());
	&#125;
&#125;</code></pre></div>

<blockquote>
<p>结论&amp;&amp;后果：当我们仅重写了 equals 保证了 “名字和年龄一样的就是一个人” 这条业务以后；把两个 pserson 对象放入 HashSet 容器里时，由于 HashSet 是通过 hashcode 来区分两个 对象存放位置，而我们又 没有根据业务逻辑重写 hashcode 方法；导致了两个 在业务上相同的对象 放到了 HashSet里，HashSet 会认为他是两个不同的对象，故最后不会去重，hashset.size()打印出来是2。</p>
</blockquote>
<h2 id="最终结论"><a href="#最终结论" class="headerlink" title="最终结论"></a>最终结论</h2><blockquote>
<p>对于重写 euqals ，要很据实际业务逻辑来，并满足上述的设计要求；一旦重写了 equals 那就必须重写 hashcode，除非你保证你的对象不会被放到 Hash 实现的容器里；不重写的话就会导致 Hash 容器认为两个属性相同的对象是2个，而不是业务上的1个。</p>
</blockquote>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/java/">Java</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/java/">Java</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a rel="license noopener" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 国际许可协议进行许可，转载请注明出处。</p>
              
              
                <div class="post-prevnext row">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2006/01/02/%E6%A1%83%E8%8A%B1%E4%BE%9D%E6%97%A7%E7%AC%91/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">桃花依旧笑</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments">
                
                
  <div class="disqus" style="width:100%">
    <div id="disqus_thread"></div>
    <script type="text/javascript">
      var disqus_config = function () {
        this.page.url = 'https://mritd.com/2006/01/02/%E6%B5%85%E8%B0%88-java%E4%B8%AD%E7%9A%84-equals-%E5%92%8C-hashcode/';
        this.page.identifier = '/2006/01/02/%E6%B5%85%E8%B0%88-java%E4%B8%AD%E7%9A%84-equals-%E5%92%8C-hashcode/';
      };
      function loadDisqus() {
        (function () {
          var d = document,
            s = d.createElement('script');
          s.src = '//' + 'mritd' + '.disqus.com/embed.js';
          s.setAttribute('data-timestamp', new Date());
          (d.head || d.body).appendChild(s);
        })();
      }
      waitElementVisible('disqus_thread', loadDisqus);
    </script>
    <noscript>Please enable JavaScript to view the
      <a href="https://disqus.com/?ref_noscript" target="_blank" rel="nofollow noopener noopener">comments powered by Disqus.</a>
    </noscript>
  </div>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener">
        <span>Fluid</span></a>
    </div>
    

    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/main.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>







  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: '#post-body',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 3,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "浅谈 java中的 equals 和 hashcode&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 80,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
      icon: "❡"
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>




















</body>
</html>
